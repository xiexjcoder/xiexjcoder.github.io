<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单元测试工具-Junit</title>
    <url>/2019/11/26/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Junit/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>JUnit是编写可重复测试的简单框架。它是用于单元测试框架的xUnit体系结构的一个实例。</li>
<li>拓展 xUnit<ul>
<li>PythonUnit</li>
<li>CppUnit</li>
<li>Junit</li>
</ul>
</li>
<li><a href="https://github.com/junit-team/junit4/wiki/Download-and-Install" target="_blank" rel="noopener">下载</a></li>
</ul>
]]></content>
      <categories>
        <category>基础学习篇</category>
      </categories>
  </entry>
  <entry>
    <title>DOS常用命令</title>
    <url>/2019/11/25/DOS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="DOS常用命令："><a href="#DOS常用命令：" class="headerlink" title="DOS常用命令："></a>DOS常用命令：</h1><ul>
<li><p>ping </p>
<ul>
<li>使用格式：ping+空格键+地址+命令参数<ol>
<li>经典用法一：检查网速状态的好坏（这里指的是网络延时的高低，不是下载速度。）</li>
</ol>
<ul>
<li>格式：输入ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> -t,输入完成之后敲击键盘的回车键来执行输入的命令。</li>
<li>命令解释：-t参数代表的是循环执行这条命令，如果不加-t的话就执行4条命令行之后就自动终止。我们重点看时间=多少毫秒。这个值越高说明你的网络越不稳定，网络延时就高。当你打开网页的时候就比较慢。所以延时越低越好，最好是10毫秒以下。还有一种情况是数据丢包，隔一行出一次数据。比如说我们打游戏的时候，就是对那种延时特别敏感的游戏。丢2个数据包就可以感觉出来，症状就是你本来点击鼠标操作了但在游戏里面没有反馈出你的操作，这就是明显的数据丢包。</li>
</ul>
<ol start="2">
<li>经典用法二：检查IP地址的连通性和判断外网状态。</li>
</ol>
<ul>
<li>格式：输入ping IP地址 -t，输入完成之后敲击键盘上的回车键。</li>
<li>首先我们控制面板找到网络连接然后查看本地连接—&gt;- 进入本地连接—&gt; 详细信息—&gt; 查看本机ip以及路由网关</li>
<li>192.168.1.1这个地址是你路由器网关的ip地址。如果我们的电脑无法上网了，就用命令去ping网关的地址查看连通的状态。</li>
<li>命令行说明：小于1毫秒说明是局域网状态。来自192.168.1.1的回复：字节、时间等信息说明本地网卡的网线连接到路由器这段是连通的状态，如果不是上面的信息请检测网线是否存在问题。如果本机到路由器连通了还是不能连接外网，说明路由器本身故障或者网络供应商故障。</li>
</ul>
</li>
</ul>
</li>
<li><p>dir </p>
<ul>
<li>显示指定路径上所有文件或目录的信息</li>
<li>格式为”dir [盘符：][路径][文件名] [参数]”，比如”DIR D:\source”</li>
</ul>
</li>
<li><p>md(mkdir)</p>
<ul>
<li>建立目录</li>
<li>格式为”md [盘符][路径]”，例如”MD test”</li>
</ul>
</li>
<li><p>rd(rmdir)</p>
<ul>
<li>删除目录</li>
<li>格式为”RD [盘符][路径]”。</li>
<li>注意：该命令只能删除空目录，并且不能删除当前目录。</li>
</ul>
</li>
<li><p>cd</p>
<ul>
<li>进入指定目录</li>
<li>格式为” CD [路径]”，例如”CD HAPPY”。</li>
<li>注意：只能进入当前盘符中的目录。其中”CD\”为回到根目录，”CD..”为回到上一层目录。</li>
</ul>
</li>
<li><p>copy</p>
<ul>
<li>拷贝文件</li>
<li>格式为”COPY [源目录或文件] [目的目录或文件]”，比如”COPY C:*.COM D:\”</li>
<li>注意：使用该命令进行文件拷贝时，目的目录一定要存在。</li>
</ul>
</li>
<li><p>del</p>
<ul>
<li>删除文件</li>
<li>格式为”DEL [盘符][路径][文件名] [参数]”，比如”DEL C:\DATA*.BAK”。它有一个参数：”/P”，可以使用户在删除多个文件时对每个文件都显示删除询问</li>
</ul>
</li>
<li><p>move</p>
<ul>
<li>移动文件，改目录名</li>
<li>格式为”MOVE [盘符][路径]”。</li>
</ul>
</li>
<li><p>ren(rename)</p>
<ul>
<li>改名</li>
<li>格式为”REN [原名] [现名]”，7.0以后版本的DOS都支持对文件名和目录名的修改，而以前的DOS只能修改文件名。</li>
</ul>
</li>
<li><p>cls</p>
<ul>
<li>清除显示器屏幕上的内容，使DOS提示符到屏幕左上角。</li>
<li>[格式] cls</li>
</ul>
</li>
<li><p>time  </p>
<ul>
<li>显示和设置DOS的系统时间</li>
<li>[格式] time [hh[:mm[:ss[.cc]]]</li>
</ul>
</li>
<li><p>date</p>
<ul>
<li>显示和设置DOS的系统日期</li>
<li>[格式] date [MM-DD-YY]</li>
</ul>
</li>
<li><p>ver</p>
<ul>
<li>显示正在运行的DOS系统版本号</li>
<li>[格式] ver</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础学习篇</category>
      </categories>
  </entry>
  <entry>
    <title>每天一梗</title>
    <url>/2019/11/24/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%A2%97/</url>
    <content><![CDATA[<ul>
<li>做轮子 ： “造轮子”的含义：明知道你做的不可能比前辈做得更好，却仍然坚持要做。<br>比如，车轮子是圆形的，这是大家公认的最合适的形状。而自己非要发明另一种形状的轮子，这种行为就叫重复发明轮子，即“造轮子”。<br>IT界指把别人已经做好的类库，自己再重新做一遍</li>
</ul>
]]></content>
      <categories>
        <category>手记</category>
      </categories>
  </entry>
  <entry>
    <title>Redis入门篇</title>
    <url>/2019/11/23/Redis%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul>
<li>NoSQL概述<ul>
<li>NoSQL = Not Only SQL</li>
<li>菲关系型数据库</li>
</ul>
</li>
<li>为什么要用NoSQL<ul>
<li>High performance - 高并发读写</li>
<li>Huge Storage - 海量数据的高效率存储和访问</li>
<li>High Scalability &amp;&amp; High Availability - 高可拓展性和高可用性</li>
</ul>
</li>
<li>NoSQL数据库的四大分类<ul>
<li>键值（Key - Value）存储</li>
<li>列存储</li>
<li>文档数据库</li>
<li>图形数据库</li>
</ul>
</li>
<li>四类NoSQL数据库比较</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>相关产品</th>
<th>典型应用</th>
<th>数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>键值（key-value）</td>
<td>Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</td>
<td>内存缓存，主要用于处理大量数据的高访问负载</td>
<td>一系列键值对</td>
<td>快速查询</td>
<td>存储的数据缺少结构化</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra、HBase、Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将统一列数据存在一起</td>
<td>查找书读快、可拓展性强，更容易进行分布式拓展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>CouchDB、MongoDB</td>
<td>Web应用（与Key-value类似，value是结构化的）</td>
<td>一系列键值对</td>
<td>数据结构要求不严格</td>
<td>查询性能不高，而且缺乏统一的查询语法</td>
</tr>
<tr>
<td>图形(Graph)数据库</td>
<td>Neo4J、InfoGrid、Infinite Graph</td>
<td>社交网络，推荐系统等。专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法</td>
<td>需要对整个图做计算才能得到出结果，不容易做分布式的集群方案</td>
</tr>
</tbody></table>
<ul>
<li>NoSQL特点<ul>
<li>易拓展</li>
<li>灵活的数据模型</li>
<li>大量数据，高性能</li>
<li>高可用</li>
</ul>
</li>
</ul>
<h1 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h1><ul>
<li><p>高性能键值对数据库，支持的键值数据类型：</p>
<ul>
<li>字符串类型</li>
<li>列表类型</li>
<li>散列类型</li>
<li>集合类型</li>
<li>有序集合类型</li>
</ul>
</li>
<li><p>Redis的应用场景</p>
<ul>
<li>缓存</li>
<li>消息队列</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理</li>
<li>分布式集群架构中的session分离</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础学习篇</category>
      </categories>
  </entry>
  <entry>
    <title>每日工作内容清单</title>
    <url>/2019/11/23/%E6%AF%8F%E6%97%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<p>2019/11/26<br>学习maven、Junit、string<br>总结归纳 maven、Junit、string 以及idea相关内容</p>
]]></content>
  </entry>
  <entry>
    <title>IDEA使用记录</title>
    <url>/2019/11/23/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="IDEA-Java相关开发配置"><a href="#IDEA-Java相关开发配置" class="headerlink" title="IDEA Java相关开发配置"></a>IDEA Java相关开发配置</h1><h2 id="IntelliJ-IDEA-配置JDK"><a href="#IntelliJ-IDEA-配置JDK" class="headerlink" title="IntelliJ IDEA 配置JDK"></a>IntelliJ IDEA 配置JDK</h2><ul>
<li>启动页面中配置JDK<ul>
<li>在IDEA启动页面中，下拉Configure，选择Project Defaults – Project Structure</li>
<li>在打开的窗口中，点击New按钮，并选择JDK</li>
<li>选择对应的JDK版本，点击OK按钮</li>
</ul>
</li>
<li>新建项目前配置JDK<ul>
<li>打开IDEA集成开发环境工具，点击：File–Project Structure (Ctrl + shift + Alt + s);</li>
<li>选择SDKs属性，并点击中间的加号+，选择JDK;</li>
<li>选择本地计算机中已经安装的JDK目录(选择bin目录的上一级即可)，然后点击ok按钮;</li>
<li>然后在Project Structure窗口，依次点击Apply–OK;</li>
</ul>
</li>
<li>新建项目中配置JDK<ul>
<li>打开IDEA集成开发环境工具，点击：File–New–Project;</li>
<li>在打开的窗口中，选择按钮New;</li>
<li>然后选择对应的JDK版本，点击OK按钮;</li>
<li>最后Next创建项目，并使用配置的JDK</li>
</ul>
</li>
<li>切换项目的JDK<ul>
<li>打开IDEA集成开发环境工具，点击：File–Project Structure (Ctrl + shift + Alt + s);</li>
<li>在打开的窗口中，选择Project，然后在详情页面中，选择按钮New，并点击JDK选项;</li>
<li>选择对应的JDK版本，点击OK按钮;<h2 id="IntelliJ-IDEA-配置MAVEN"><a href="#IntelliJ-IDEA-配置MAVEN" class="headerlink" title="IntelliJ IDEA 配置MAVEN"></a>IntelliJ IDEA 配置MAVEN</h2></li>
</ul>
</li>
</ul>
<h1 id="idea快捷键："><a href="#idea快捷键：" class="headerlink" title="idea快捷键："></a>idea快捷键：</h1><h2 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h2><p>编辑快捷 键    介绍<br>Tab    缩进 / 配合代码提示实现自动完成<br>Shift + Tab    取消缩进<br>Ctrl + Z    撤销<br>Ctrl + Shift + Z    取消撤销<br>Ctrl + Y    删除光标所在行 或 删除选中的行<br>Ctrl + X    剪切光标所在行 或 剪切选择内容<br>Ctrl + C    复制光标所在行 或 复制选择内容<br>Ctrl + V    在光标所在处粘贴已复制内容<br>Ctrl + Shift + V    弹出历史复制内容<br>Ctrl + D    复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面<br>Ctrl + W    递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围<br>Ctrl + Shift + W    递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围<br>Ctrl + /    注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号<br>Ctrl + Shift + /    代码块注释<br>Ctrl + +    展开代码<br>Ctrl + -    折叠代码<br>Ctrl + Shift + +    展开所有代码<br>Ctrl + Shift + -    折叠所有代码<br>Alt +    鼠标左键上下拖动 多行编辑<br>Alt + Shift +    鼠标左键多行选择 自定义多行编辑<br>Ctrl + Shift +    前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序。光标放在普通代码行上，将改行上移<br>Ctrl + Shift +    后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序。光标放在普通代码行上，将改行下移</p>
<h2 id="查找替换快捷键"><a href="#查找替换快捷键" class="headerlink" title="查找替换快捷键"></a>查找替换快捷键</h2><p>查找替换快捷键    介绍<br>Ctrl + F    在当前文件中进行文本查找<br>Ctrl + Shift + F    在整个项目或者指定目录内的文件中进行文本查找<br>Ctrl + N    根据输入的 类名 查找类文件<br>Ctrl + Shift + N    通过文件名定位，打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠<br>Ctrl + Shift + Alt + N    查找 变量 / 方法<br>双击Shift    弹出 Search Everywhere 弹出层<br>Alt + F3    高亮显示所有该选中文本，按 Enter 选中下一个，按 Esc 高亮消失，推荐使用Ctrl+F<br>Ctrl + Shift + F7    高亮显示所有该选中文本，按 Esc 高亮消失，推荐使用Ctrl+F 或 Alt + F3<br>Ctrl + E    显示最近打开的文件记录列表<br>Ctrl + Shift + E    显示最近修改的文件列表的弹出层<br>Ctrl + F12    弹出当前文件结构层（如查看当前类的所有方法），可以在弹出的层上直接输入，进行筛选<br>Ctrl + H    显示当前类的继承层次结构（包含其父类和子类）<br>Ctrl + R    在当前文件进行文本替换<br>Ctrl + Shift + R    根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件<br>光标定位快捷键    介绍<br>Ctrl + Home    跳到文件头<br>Ctrl + End    跳到文件尾<br>Ctrl + Shift + Backspace    退回到上次修改的地方<br>Ctrl + Alt + 左方向键    退回到上一个操作的地方<br>Ctrl + Alt + 右方向键    前进到上一个操作的地方<br>Alt + 前方向键    当前光标跳转到当前文件的前一个方法名位置<br>Alt + 后方向键    当前光标跳转到当前文件的后一个方法名位置<br>窗口导航快捷键<br>窗口导航快捷键    介绍<br>Ctrl + Tab    编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口<br>Alt + 1,2,3…9    显示对应数值的选项卡，其中 1 是 Project 用得最多<br>ESC    从工具窗口进入代码文件窗口，或退出打开的窗口<br>代码自动档快捷键<br>代码自动档快捷键    介绍<br>Ctrl + Space    基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号<br>Ctrl + Shift + Space    智能代码提示<br>Ctrl + J    显示与之匹配的实时代码模板<br>Shift + Enter    开始新一行。光标所在行下空出一行，光标定位到新行位置<br>Ctrl + Shift + Enter    自动结束代码，行末自动添加 分号/括号/引号 等，if/for等会自动添加所需结构<br>Ctrl + Alt + Enter    光标所在行上空出一行，光标定位到新行<br>Ctrl + Enter    智能分隔行<br>Ctrl + Shift + J    自动将下一行合并到当前行末尾<br>Ctrl + Shift + U    对选中的代码进行大 / 小写轮流转换<br>Ctrl + Alt + L    格式化代码，可以对当前文件和整个包目录使用<br>Ctrl + Alt + O    优化导入的类，可以对当前文件和整个包目录使用<br>Alt + Insert    在类中使用可以自动生成代码（如 getter/setter，构造函数，toString()<br>Ctrl + Alt + T    对选中的代码弹出环绕选项弹出层<br>Ctrl + Shift + T    对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择<br>Ctrl + O    选择可重写的方法<br>Ctrl + I    选择可继承的方法<br>代码重构快捷键<br>代码重构快捷键    介绍<br>Shift + F6    对 文件夹 / 文件 / 类 / 方法 / 变量 (重构)重命名<br>Ctrl + Shift + Alt + T    重构功能大汇总，叫做 Refactor This<br>代码追踪快捷键<br>代码追踪快捷键    介绍<br>Ctrl + B    进入光标所在的方法/变量的接口或定义处，等效于 Ctrl + 左键单击<br>Alt + F7    查找光标所在的 方法 / 变量 / 类 被使用的地方<br>Ctrl + Alt + F7    查找光标所在的 方法 / 变量 / 类 被使用的地方，用弹出框的方式找出来<br>编译调试运行快捷键<br>编译调试运行快捷键    介绍<br>Ctrl + F9    执行 Make Project 操作，编译所有<br>Ctrl + Shift + F9    编译选中的 文件 / 包 / Module<br>Shift + F10    等效于点击工具栏的 Run 按钮<br>Alt + Shift + F10    弹出 Run 的可选择菜单<br>Shift + F9    等效于点击工具栏的 Debug 按钮<br>Alt + Shift + F9    弹出 Debug 的可选择菜单<br>F7    在 Debug 模式下，进入下一步，即 Step into。如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中<br>F8    在 Debug 模式下，进入下一步，即 Step over。如果当前行断点是一个方法，则不进入当前方法体内<br>F9    在 Debug 模式下，恢复程序运行，即 Continue。但是如果该断点下面代码还有断点则停在下一个断点上<br>F2    跳转到下一个高亮错误 或 警告位置<br>Shift + F2    跳转到上一个高亮错误 或 警告位置<br>Alt + Enter    IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同<br>其他<br>其他快捷键    介绍<br>Ctrl + Alt + S    打开 IntelliJ IDEA 系统设置<br>Ctrl + Shift + Alt + S    打开当前项目设置<br>Ctrl + Alt + Y    同步、刷新<br>Shift + 滚轮前后滚动    当前文件的横向滚动轴滚动<br>Ctrl + 左键单击    在打开的文件标题上，弹出该文件路径</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——设计模式</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h3><ul>
<li><h4 id="说一下你熟悉的设计模式？"><a href="#说一下你熟悉的设计模式？" class="headerlink" title="说一下你熟悉的设计模式？"></a>说一下你熟悉的设计模式？</h4></li>
</ul>
<ul>
<li><p>单例模式<br>  简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。<br>  getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  按照我的习惯，我恨不得写满注释，怕你们看不懂，但是这个代码实在太简单了，所以我没写任何注释，如果这几行代码你都看不明白的话，那你可以洗洗睡了，等你睡醒了再来看我的博客说不定能看懂。<br>  上面的是最基本的写法，也叫懒汉写法（线程不安全）下面我再公布几种单例模式的写法：<br>  <strong>懒汉式写法（线程安全）</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>饿汉式写法</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>静态内部类</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">        return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>枚举</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。<br>  <strong>双重校验锁</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            synchronized (Singleton.class) &#123;  </span><br><span class="line">                if (singleton == null) &#123;  </span><br><span class="line">                    singleton = new Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  总结：我个人比较喜欢静态内部类写法和饿汉式写法，其实这两种写法能够应付绝大多数情况了。其他写法也可以选择，主要还是看业务需求吧。</p>
</li>
</ul>
<ul>
<li><p><strong>观察者模式</strong><br>  对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>  观察者模式UML图<br>  看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。”这句话被小王和小李听到了，结果乐坏了，蹭蹭蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进行相应的处理，看代码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Person &#123;</span><br><span class="line">    //小王和小李通过这个接口可以接收到小美发过来的消息</span><br><span class="line">    void getMessage(String s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关系，先往下看</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LaoWang implements Person &#123;</span><br><span class="line">    private String name = &quot;小王&quot;;</span><br><span class="line">    public LaoWang() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void getMessage(String s) &#123;</span><br><span class="line">        System.out.println(name + &quot;接到了小美打过来的电话，电话内容是：&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LaoLi implements Person &#123;</span><br><span class="line">    private String name = &quot;小李&quot;;</span><br><span class="line">    public LaoLi() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void getMessage(String s) &#123;</span><br><span class="line">        System.out.println(name + &quot;接到了小美打过来的电话，电话内容是：-&gt;&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  代码很简单，我们再看看小美的代码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class XiaoMei &#123;</span><br><span class="line">    List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();</span><br><span class="line">    public XiaoMei()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addPerson(Person person)&#123;</span><br><span class="line">        list.add(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历list，把自己的通知发送给所有暗恋自己的人</span><br><span class="line">    public void notifyPerson() &#123;</span><br><span class="line">        for(Person person:list)&#123;</span><br><span class="line">            person.getMessage(&quot;你们过来吧，谁先过来谁就能陪我一起玩儿游戏!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们写一个测试类来看一下结果对不对</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        XiaoMei xiao_mei = new XiaoMei();</span><br><span class="line">        LaoWang lao_wang = new LaoWang();</span><br><span class="line">        LaoLi lao_li = new LaoLi();</span><br><span class="line"></span><br><span class="line">        //小王和小李在小美那里都注册了一下</span><br><span class="line">        xiao_mei.addPerson(lao_wang);</span><br><span class="line">        xiao_mei.addPerson(lao_li);</span><br><span class="line"></span><br><span class="line">        //小美向小王和小李发送通知</span><br><span class="line">        xiao_mei.notifyPerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>装饰者模式</strong><br>  对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。（ps：不知道上海哪里有卖好吃的三明治的，求推荐～）那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所有食物都来继承这个类，看代码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Food &#123;</span><br><span class="line">    private String food_name;</span><br><span class="line"></span><br><span class="line">    public Food() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Food(String food_name) &#123;</span><br><span class="line">        this.food_name = food_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String make() &#123;</span><br><span class="line">        return food_name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  代码很简单，我就不解释了，然后我们写几个子类继承它：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//面包类</span><br><span class="line">public class Bread extends Food &#123;</span><br><span class="line"></span><br><span class="line">    private Food basic_food;</span><br><span class="line"></span><br><span class="line">    public Bread(Food basic_food) &#123;</span><br><span class="line">        this.basic_food = basic_food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String make() &#123;</span><br><span class="line">        return basic_food.make()+&quot;+面包&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//奶油类</span><br><span class="line">public class Cream extends Food &#123;</span><br><span class="line"></span><br><span class="line">    private Food basic_food;</span><br><span class="line"></span><br><span class="line">    public Cream(Food basic_food) &#123;</span><br><span class="line">        this.basic_food = basic_food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String make() &#123;</span><br><span class="line">        return basic_food.make()+&quot;+奶油&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//蔬菜类</span><br><span class="line">public class Vegetable extends Food &#123;</span><br><span class="line"></span><br><span class="line">    private Food basic_food;</span><br><span class="line"></span><br><span class="line">    public Vegetable(Food basic_food) &#123;</span><br><span class="line">        this.basic_food = basic_food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String make() &#123;</span><br><span class="line">        return basic_food.make()+&quot;+蔬菜&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的Test类是怎么写的，一看你就明白了</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Food food = new Bread(new Vegetable(new Cream(new Food(&quot;香肠&quot;))));</span><br><span class="line">        System.out.println(food.make());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？ 我们看看运行结果吧<br>  运行结果<br>  一个三明治就做好了～</p>
</li>
<li><p><strong>适配器模式</strong><br>  将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        VoltageAdapter adapter = new VoltageAdapter();</span><br><span class="line">        phone.setAdapter(adapter);</span><br><span class="line">        phone.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 手机类</span><br><span class="line">class Phone &#123;</span><br><span class="line"></span><br><span class="line">    public static final int V = 220;// 正常电压220v，是一个常量</span><br><span class="line"></span><br><span class="line">    private VoltageAdapter adapter;</span><br><span class="line"></span><br><span class="line">    // 充电</span><br><span class="line">    public void charge() &#123;</span><br><span class="line">        adapter.changeVoltage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAdapter(VoltageAdapter adapter) &#123;</span><br><span class="line">        this.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 变压器</span><br><span class="line">class VoltageAdapter &#123;</span><br><span class="line">    // 改变电压的功能</span><br><span class="line">    public void changeVoltage() &#123;</span><br><span class="line">        System.out.println(&quot;正在充电...&quot;);</span><br><span class="line">        System.out.println(&quot;原始电压：&quot; + Phone.V + &quot;V&quot;);</span><br><span class="line">        System.out.println(&quot;经过变压器转换之后的电压:&quot; + (Phone.V - 200) + &quot;V&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工厂模式</strong><br>  简单工厂模式：一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 抽象产品类</span><br><span class="line">abstract class Car &#123;</span><br><span class="line">    public void run();</span><br><span class="line"></span><br><span class="line">    public void stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 具体实现类</span><br><span class="line">class Benz implements Car &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Benz开始启动了。。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;Benz停车了。。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Ford implements Car &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Ford开始启动了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;Ford停车了。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 工厂类</span><br><span class="line">class Factory &#123;</span><br><span class="line">    public static Car getCarInstance(String type) &#123;</span><br><span class="line">        Car c = null;</span><br><span class="line">        if (&quot;Benz&quot;.equals(type)) &#123;</span><br><span class="line">            c = new Benz();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;Ford&quot;.equals(type)) &#123;</span><br><span class="line">            c = new Ford();</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car c = Factory.getCarInstance(&quot;Benz&quot;);</span><br><span class="line">        if (c != null) &#123;</span><br><span class="line">            c.run();</span><br><span class="line">            c.stop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;造不了这种汽车。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  工厂方法模式：有四个角色，抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 抽象产品角色</span><br><span class="line">public interface Moveable &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 具体产品角色</span><br><span class="line">public class Plane implements Moveable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;plane....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Broom implements Moveable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;broom.....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 抽象工厂</span><br><span class="line">public abstract class VehicleFactory &#123;</span><br><span class="line">    abstract Moveable create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 具体工厂</span><br><span class="line">public class PlaneFactory extends VehicleFactory &#123;</span><br><span class="line">    public Moveable create() &#123;</span><br><span class="line">        return new Plane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BroomFactory extends VehicleFactory &#123;</span><br><span class="line">    public Moveable create() &#123;</span><br><span class="line">        return new Broom();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 测试类</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        VehicleFactory factory = new BroomFactory();</span><br><span class="line">        Moveable m = factory.create();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  抽象工厂模式：与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//抽象工厂类</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract Vehicle createVehicle();</span><br><span class="line">    public abstract Weapon createWeapon();</span><br><span class="line">    public abstract Food createFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span><br><span class="line">public class DefaultFactory extends AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Food createFood() &#123;</span><br><span class="line">        return new Apple();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Vehicle createVehicle() &#123;</span><br><span class="line">        return new Car();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Weapon createWeapon() &#123;</span><br><span class="line">        return new AK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractFactory f = new DefaultFactory();</span><br><span class="line">        Vehicle v = f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        Weapon w = f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        Food a = f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代理模式（proxy）</strong><br>  有两种，静态代理和动态代理。先说静态代理，很多理论性的东西我不讲，我就算讲了，你们也看不懂。什么真实角色，抽象角色，代理角色，委托角色。。。乱七八糟的，我是看不懂。之前学代理模式的时候，去网上翻一下，资料一大堆，打开链接一看，基本上都是给你分析有什么什么角色，理论一大堆，看起来很费劲，不信的话你们可以去看看，我是看不懂他们在说什么。咱不来虚的，直接用生活中的例子说话。（注意：我这里并不是否定理论知识，我只是觉得有时候理论知识晦涩难懂，喜欢挑刺的人一边去，你是来学习知识的，不是来挑刺的）<br>  到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样的：家里人催婚-&gt;男女双方家庭商定结婚的黄道即日-&gt;找一家靠谱的婚庆公司-&gt;在约定的时间举行结婚仪式-&gt;结婚完毕<br>  婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知。。。别担心，不是黑中介，我们只要把钱给人家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色，现在明白什么是代理角色了吧。<br>  代码实现请看：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代理接口</span><br><span class="line">public interface ProxyInterface &#123;</span><br><span class="line">    //需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写</span><br><span class="line">    void marry();</span><br><span class="line">    //代理吃饭(自己的饭，让别人吃去吧)</span><br><span class="line">    //void eat();</span><br><span class="line">    //代理拉屎，自己的屎，让别人拉去吧</span><br><span class="line">    //void shit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  文明社会，代理吃饭，代理拉屎什么的我就不写了，有伤社会风化～～～能明白就好<br>  好了，我们看看婚庆公司的代码:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WeddingCompany implements ProxyInterface &#123;</span><br><span class="line">    private ProxyInterface proxyInterface;</span><br><span class="line">    public WeddingCompany(ProxyInterface proxyInterface) &#123;</span><br><span class="line">        this.proxyInterface = proxyInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void marry() &#123;</span><br><span class="line">        System.out.println(&quot;我们是婚庆公司的&quot;);</span><br><span class="line">        System.out.println(&quot;我们在做结婚前的准备工作&quot;);</span><br><span class="line">        System.out.println(&quot;节目彩排...&quot;);</span><br><span class="line">        System.out.println(&quot;礼物购买...&quot;);</span><br><span class="line">        System.out.println(&quot;工作人员分工...&quot;);</span><br><span class="line">        System.out.println(&quot;可以开始结婚了&quot;);</span><br><span class="line">        proxyInterface.marry();</span><br><span class="line">        System.out.println(&quot;结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  看到没有，婚庆公司需要做的事情很多，我们再看看结婚家庭的代码:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NormalHome implements ProxyInterface&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void marry() &#123;</span><br><span class="line">    System.out.println(&quot;我们结婚啦～&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这个已经很明显了，结婚家庭只需要结婚，而婚庆公司要包揽一切，前前后后的事情都是婚庆公司来做，听说现在婚庆公司很赚钱的，这就是原因，干的活多，能不赚钱吗？<br>  来看看测试类代码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    ProxyInterface proxyInterface = new WeddingCompany(new NormalHome());</span><br><span class="line">        proxyInterface.marry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行结果如下：<br>  在我们预料中，结果正确，这就是静态代理，动态代理我就不想说了，跟java反射有关系，网上资料很多，我以后有时间再更新吧。</p>
</li>
<li><h4 id="简单工厂和抽象工厂有什么区别？"><a href="#简单工厂和抽象工厂有什么区别？" class="headerlink" title="简单工厂和抽象工厂有什么区别？"></a>简单工厂和抽象工厂有什么区别？</h4><ul>
<li><strong>简单工厂模式：</strong><br>  这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。<br>  它由三种角色组成：<ul>
<li>工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。</li>
<li>抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的Car接口。</li>
<li>具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。<br>来用类图来清晰的表示下的它们之间的关系：</li>
</ul>
</li>
<li><strong>抽象工厂模式：</strong><br>  先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。<br>  点击查看原始大小图片<br>  图中的BmwCar和BenzCar就是两个产品树（产品层次结构）；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理BmwBussinessCar和BenzBusinessCar也是一个产品族。<br>  可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。<br>  而且使用抽象工厂模式还要满足一下条件：<ul>
<li>系统中有多个产品族，而系统一次只可能消费其中一族产品</li>
<li>同属于同一个产品族的产品以其使用。<br>来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：</li>
<li>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。</li>
<li>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。</li>
<li>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。</li>
<li>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——中间件</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="9-中间件-rocketmq-rabbitmq-kafka"><a href="#9-中间件-rocketmq-rabbitmq-kafka" class="headerlink" title="9. 中间件 rocketmq/rabbitmq/kafka"></a>9. <strong>中间件 rocketmq/rabbitmq/kafka</strong></h3><ul>
<li><h4 id="rabbitmq-的使用场景有哪些？"><a href="#rabbitmq-的使用场景有哪些？" class="headerlink" title="rabbitmq 的使用场景有哪些？"></a>rabbitmq 的使用场景有哪些？</h4><p>  ①. 跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。<br>  ②. 多个应用之间的耦合，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。<br>  ③. 应用内的同步变异步，比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。<br>  ④. 消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。<br>  ⑤. 应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。<br>  ⑥. 跨局域网，甚至跨城市的通讯（CDN行业），比如北京机房与广州机房的应用程序的通信。</p>
</li>
<li><h4 id="rabbitmq-有哪些重要的角色？"><a href="#rabbitmq-有哪些重要的角色？" class="headerlink" title="rabbitmq 有哪些重要的角色？"></a>rabbitmq 有哪些重要的角色？</h4><p>  RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<ul>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
</li>
<li><h4 id="rabbitmq-有哪些重要的组件？"><a href="#rabbitmq-有哪些重要的组件？" class="headerlink" title="rabbitmq 有哪些重要的组件？"></a>rabbitmq 有哪些重要的组件？</h4><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
</li>
<li><h4 id="rabbitmq-中-vhost-的作用是什么？"><a href="#rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="rabbitmq 中 vhost 的作用是什么？"></a>rabbitmq 中 vhost 的作用是什么？</h4><p>  vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ  server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 </p>
</li>
<li><h4 id="rabbitmq-的消息是怎么发送的？"><a href="#rabbitmq-的消息是怎么发送的？" class="headerlink" title="rabbitmq 的消息是怎么发送的？"></a>rabbitmq 的消息是怎么发送的？</h4><p>  首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
</li>
<li><h4 id="rabbitmq-怎么保证消息的稳定性？"><a href="#rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="rabbitmq 怎么保证消息的稳定性？"></a>rabbitmq 怎么保证消息的稳定性？</h4><ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
</li>
<li><h4 id="rabbitmq-怎么避免消息丢失？"><a href="#rabbitmq-怎么避免消息丢失？" class="headerlink" title="rabbitmq 怎么避免消息丢失？"></a>rabbitmq 怎么避免消息丢失？</h4><ul>
<li>消息持久化</li>
<li>ACK确认机制</li>
<li>设置集群镜像模式</li>
<li>消息补偿机制</li>
</ul>
</li>
<li><h4 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h4><ul>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。</li>
<li>以上四个条件都满足才能保证消息持久化成功。</li>
</ul>
</li>
<li><h4 id="rabbitmq-持久化有什么缺点？"><a href="#rabbitmq-持久化有什么缺点？" class="headerlink" title="rabbitmq 持久化有什么缺点？"></a>rabbitmq 持久化有什么缺点？</h4><p>  持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
</li>
<li><h4 id="rabbitmq-有几种广播类型？"><a href="#rabbitmq-有几种广播类型？" class="headerlink" title="rabbitmq 有几种广播类型？"></a>rabbitmq 有几种广播类型？</h4><p>  三种广播模式：</p>
<ul>
<li>fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</li>
<li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</li>
<li>topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；</li>
</ul>
</li>
<li><h4 id="rabbitmq-怎么实现延迟消息队列？"><a href="#rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="rabbitmq 怎么实现延迟消息队列？"></a>rabbitmq 怎么实现延迟消息队列？</h4><ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
</li>
<li><h4 id="rabbitmq-集群有什么用？"><a href="#rabbitmq-集群有什么用？" class="headerlink" title="rabbitmq 集群有什么用？"></a>rabbitmq 集群有什么用？</h4><p>  集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
</li>
<li><h4 id="rabbitmq-节点的类型有哪些？"><a href="#rabbitmq-节点的类型有哪些？" class="headerlink" title="rabbitmq 节点的类型有哪些？"></a>rabbitmq 节点的类型有哪些？</h4><ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
</li>
<li><h4 id="rabbitmq-集群搭建需要注意哪些问题？"><a href="#rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="rabbitmq 集群搭建需要注意哪些问题？"></a>rabbitmq 集群搭建需要注意哪些问题？</h4><ul>
<li>各节点之间使用“–link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
</li>
<li><h4 id="rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h4><p>  不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
</li>
<li><h4 id="rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h4><p>  如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</li>
</ul>
</li>
<li><h4 id="rabbitmq-对集群节点停止顺序有要求吗？"><a href="#rabbitmq-对集群节点停止顺序有要求吗？" class="headerlink" title="rabbitmq 对集群节点停止顺序有要求吗？"></a>rabbitmq 对集群节点停止顺序有要求吗？</h4><p>  RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
</li>
<li><h4 id="kafka可以脱离zookeeper单独使用吗？为什么？"><a href="#kafka可以脱离zookeeper单独使用吗？为什么？" class="headerlink" title="kafka可以脱离zookeeper单独使用吗？为什么？"></a>kafka可以脱离zookeeper单独使用吗？为什么？</h4><p>  kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
</li>
<li><h4 id="kafka有几种数据保留的策略？"><a href="#kafka有几种数据保留的策略？" class="headerlink" title="kafka有几种数据保留的策略？"></a>kafka有几种数据保留的策略？</h4><p>  kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
</li>
<li><h4 id="kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？"><a href="#kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？" class="headerlink" title="kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？"></a>kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？</h4><p>  这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
</li>
<li><h4 id="什么情况会导致kafka运行变慢？"><a href="#什么情况会导致kafka运行变慢？" class="headerlink" title="什么情况会导致kafka运行变慢？"></a>什么情况会导致kafka运行变慢？</h4><ul>
<li>cpu 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
</li>
<li><h4 id="使用kafka集群需要注意什么？"><a href="#使用kafka集群需要注意什么？" class="headerlink" title="使用kafka集群需要注意什么？"></a>使用kafka集群需要注意什么？</h4><ul>
<li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li>
<li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li>
</ul>
</li>
<li><h4 id="zookeeper是什么？"><a href="#zookeeper是什么？" class="headerlink" title="zookeeper是什么？"></a>zookeeper是什么？</h4><p>  zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
</li>
<li><h4 id="zookeeper都有哪些功能、"><a href="#zookeeper都有哪些功能、" class="headerlink" title="zookeeper都有哪些功能、"></a>zookeeper都有哪些功能、</h4><ul>
<li>集群管理：监控节点存活状态、运行请求等。</li>
<li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li>
<li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li>
<li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
</ul>
</li>
<li><h4 id="zookeeper有哪几种部署模式？"><a href="#zookeeper有哪几种部署模式？" class="headerlink" title="zookeeper有哪几种部署模式？"></a>zookeeper有哪几种部署模式？</h4><p>  zookeeper 有三种部署模式：</p>
<ul>
<li>单机部署：一台集群上运行；</li>
<li>集群部署：多台集群运行；</li>
<li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li>
</ul>
</li>
<li><h4 id="zookeeper怎么保证主从借点的状态同步？"><a href="#zookeeper怎么保证主从借点的状态同步？" class="headerlink" title="zookeeper怎么保证主从借点的状态同步？"></a>zookeeper怎么保证主从借点的状态同步？</h4><p>  zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
</li>
<li><h4 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h4><p>  在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
</li>
<li><h4 id="集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？"><a href="#集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？" class="headerlink" title="集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？"></a>集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？</h4><p>  可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
</li>
<li><h4 id="说一下zookeeper的通知机制？"><a href="#说一下zookeeper的通知机制？" class="headerlink" title="说一下zookeeper的通知机制？"></a>说一下zookeeper的通知机制？</h4><p>  客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——项目</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E9%A1%B9%E7%9B%AE%E7%AF%87/</url>
    <content><![CDATA[<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a><strong>项目</strong></h3><ul>
<li><h4 id="介绍一下开发过的项目"><a href="#介绍一下开发过的项目" class="headerlink" title="介绍一下开发过的项目"></a>介绍一下开发过的项目</h4><ul>
<li><strong>分析：</strong>技术官这么问我们的目的是什么？目的：1.了解项目的级别（企业级、部门级、小组级）；2.了解项目架构（开发架构、技术架构、数据架构）；3了解项目中使用的技术；4看你是否与职位匹配</li>
<li><strong>回答加分项：</strong>1.对比说明xx模块在xx条件下使用xx技术更加合理；2.现有项目中的不足，及如何优化；3.使用STAR法则表现自己【S：Situation，指的是项目背景T：Task，项目任务A：Action，你自己承担的工作R：Result，工作结果】；</li>
<li><strong>举例说明：</strong><br>1 业务需求可以一笔带过，用寥寥几句话介绍项目的背景，大致做了什么，工期和人数即可，别讲太多，因为面试官不关心。下面给出一个说辞的案例。<br>我上个项目是做电信系统的计费软件，客户是xxx，工期是xxx个月，有5个人一起做，我在里面做的是开发。<br>2 结合项目实际需求，介绍项目用到的技术，比如在上述职位描述里，要求有spring mvc，消息中间件，数据库等需求，下面同样给出各说辞的案例。<br>在这个项目里，我们用到了Spring MVC（或Spring Boot或Spring Cloud）框架，数据库是用Oracle，ORM组件是用Mytabis，在项目里，我们在是通过消息queue来发送计费成功的消息，消息中间件我们使用Kafka，为了降低数据库访问次数，我们会把客户信息放在redis缓存中。此外，我们在网关层接入了nginx做负载均衡。<br>大家能看到，在上述说辞里，我们结合了案例，说出了招聘方需要的技术点，不过请注意，这里仅仅是介绍项目，结合功能点说出技术即可，别过多展开，因为一旦过度展开，就会让面试官感觉你思路不清晰，或者凭借准备有恃无恐。<br>3 再结合项目，说些招聘方需要的非技术的要求。<br>在这个项目里，我们用到了xx设计模式，而且，我们会定期review代码，以求保证代码的质量，而且，当项目工期比较紧的时候，我还会客串配置管理的角色。在这个项目里，我一有问题，马上会和经理或测试或其它组的人沟通。<br>4 如果有，说下你在项目里的亮点，比如用到了一些比较好的技术。<br>这个项目对数据库性能和内存性能要求比较高，所以我用到了Oracle调优技术和JVM内存优化技术，此外，我们还用到了大数据分析的工具对计费模式做了优化。<br>大家看到,上述说辞不复杂，准备好以后，说起来估计也就2，3分钟 但就通过上述说辞，亮出了你的基本信息，而且能给面试官留下思路清晰，技术匹配的印象。</li>
</ul>
</li>
</ul>
<p>金疙瘩：</p>
<p>内容            现状                                引入Spring Cloud后<br>服务发现        内部域名解析                         Eureka Server注册中心<br>服务调用        封装OKHttp3的service_consumer        Spring Cloud Feign(LoadedRestTemplate)<br>负载均衡        内部域名解析                        Spring Cloud Ribbon客户端负载均衡<br>服务路由/鉴权    Nginx转发                            Spring Cloud Zuul服务网关<br>服务容错/降级    没有                                Spring Cloud Hystrix 断路器<br>配置文件        本地配置覆盖JAR包配置                服务配置中心<br>监控            没有                                Turbine + Spring Boot Admin<br>日志            FTP                                    FTP或ELK<br>服务追踪        traceID(手工)                        Spring Cloud Sleuth + Zipkin<br>文档管理        Markdown(手工)/ShowDoc                Swagger/ShowDoc</p>
<h3 id="16-你还有什么想问的问题吗？"><a href="#16-你还有什么想问的问题吗？" class="headerlink" title="16. 你还有什么想问的问题吗？"></a>16. 你还有什么想问的问题吗？</h3><p>xiexj：您认为目前阶段我有哪些方面需要进一步提高的？<br>xiexj：如果我加入到咱们团队的话，除您刚才所说的待进一步提高的内容，还有什么需要是准备的吗？<br>xiexj：您认为什么样的人是最适合这个岗位的人选呢？</p>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——LINUX</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BLinux%E7%AF%87/</url>
    <content><![CDATA[<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a><strong>linux</strong></h3><ul>
<li>常用命令<ol>
<li>查找文件<br>find / -name filename.txt<br>根据名称查找/目录下的filename.txt文件。</li>
<li>查看一个程序是否运行<br>ps –ef|grep tomcat<br>查看所有有关tomcat的进程</li>
<li>终止线程<br>kill -9 19979<br>终止线程号位19979的线程</li>
<li>查看文件，包含隐藏文件<br>ls -al</li>
<li>当前工作目录<br>pwd</li>
<li>复制文件包括其子文件到自定目录<br>cp -r sourceFolder targetFolder</li>
<li>创建目录<br>mkdir newfolder</li>
<li>删除目录（此目录是空目录）<br>rmdir deleteEmptyFolder</li>
<li>删除文件包括其子文件<br>rm -rf deleteFile</li>
<li>移动文件<br>mv /temp/movefile /targetFolder<br>扩展重命名 mv oldNameFile newNameFile</li>
<li>切换用户<br>su -username</li>
<li>修改文件权限<br>chmod 777 file.java<br>//file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</li>
<li>压缩文件<br>tar -czf test.tar.gz /test1 /test2</li>
<li>列出压缩文件列表<br>tar -tzf test.tar.gz</li>
<li>解压文件<br>tar -xvzf test.tar.gz</li>
<li>查看文件头10行<br>head -n 10 example.txt</li>
<li>查看文件尾10行<br>tail -n 10 example.txt</li>
<li>查看日志文件<br>tail -f exmaple.log<br>//这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</li>
<li>启动Vi编辑器<br>vi</li>
<li>查看系统当前时间<br>date<br>命令会输出 周几 几月 几日 时间 和 时间显示格式 和年份<br>Sat Jan 20 04:39:49 CST 2018<br>date +”%Y-%m-%d”<br>显示如下：<br>[root@ming xxx]# date +”%Y-%m-%d” 2018-01-20<br>注：这个我们如果不确定 就help 即可；</li>
<li>解压zip 文件<br>unzip -oq</li>
<li>查看线程个数（方便查看程序是否有误）<br>ps -Lf 端口号|wc -l</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——JVM</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BJVM%E7%AF%87/</url>
    <content><![CDATA[<h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a><strong>jvm</strong></h3><ul>
<li><h4 id="说一下jvm的主要组成部分？及其作用？"><a href="#说一下jvm的主要组成部分？及其作用？" class="headerlink" title="说一下jvm的主要组成部分？及其作用？"></a>说一下jvm的主要组成部分？及其作用？</h4><ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
<li>垃圾回收器<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li>
</ul>
</li>
<li><h4 id="说一下jvm运行时数据区？"><a href="#说一下jvm运行时数据区？" class="headerlink" title="说一下jvm运行时数据区？"></a>说一下jvm运行时数据区？</h4><ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区<br>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</li>
</ul>
</li>
<li><h4 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h4><ol>
<li>栈内存存储的是局部变量而堆内存存储的是实体；</li>
<li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li>
<li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li>
</ol>
</li>
<li><h4 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h4><p>  队列和栈都是被用来预存储数据的。<br>  队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>  栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
</li>
<li><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><ul>
<li>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</li>
<li>类加载器分类：<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载&lt; java_home style=”box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;”&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home></li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
</li>
<li>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</li>
</ul>
</li>
<li><h4 id="说一下类加载的执行过程？"><a href="#说一下类加载的执行过程？" class="headerlink" title="说一下类加载的执行过程？"></a>说一下类加载的执行过程？</h4><p>  类加载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
</li>
<li><h4 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h4><p>  一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
</li>
<li><h4 id="java中都有哪些引用类型？"><a href="#java中都有哪些引用类型？" class="headerlink" title="java中都有哪些引用类型？"></a>java中都有哪些引用类型？</h4><ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用（幽灵引用/幻影引用）</li>
</ul>
</li>
<li><h4 id="说一下jvn有哪些垃圾回收算法？"><a href="#说一下jvn有哪些垃圾回收算法？" class="headerlink" title="说一下jvn有哪些垃圾回收算法？"></a>说一下jvn有哪些垃圾回收算法？</h4><ul>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代算法</li>
</ul>
</li>
<li><h4 id="说一下jvm有哪些垃圾回收器？"><a href="#说一下jvm有哪些垃圾回收器？" class="headerlink" title="说一下jvm有哪些垃圾回收器？"></a>说一下jvm有哪些垃圾回收器？</h4><ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
</li>
<li><h4 id="详细介绍一下CMS垃圾回收器？"><a href="#详细介绍一下CMS垃圾回收器？" class="headerlink" title="详细介绍一下CMS垃圾回收器？"></a>详细介绍一下CMS垃圾回收器？</h4><ul>
<li>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</li>
<li>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</li>
</ul>
</li>
<li><h4 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li>
</ul>
</li>
<li><h4 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h4><ul>
<li>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</li>
<li>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
</li>
<li>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li>
<li>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</li>
</ul>
</li>
<li><h4 id="说一下jvm调优的工具？"><a href="#说一下jvm调优的工具？" class="headerlink" title="说一下jvm调优的工具？"></a>说一下jvm调优的工具？</h4><p>  JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
</li>
<li><h4 id="常用的jvm调优的参数都有哪些？"><a href="#常用的jvm调优的参数都有哪些？" class="headerlink" title="常用的jvm调优的参数都有哪些？"></a>常用的jvm调优的参数都有哪些？</h4><p>  -Xms2g：初始化推大小为 2g；</p>
<p>  -Xmx2g：堆最大内存为 2g；</p>
<p>  -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</p>
<p>  -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</p>
<p>  –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p>
<p>  -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p>
<p>  -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p>
<p>  -XX:+PrintGC：开启打印 gc 信息；</p>
<p>  -XX:+PrintGCDetails：打印 gc 详细信息。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——开源框架</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E7%AF%87/</url>
    <content><![CDATA[<h3 id="开源框架spring、springmvc、springboot、springcloud、mybatis"><a href="#开源框架spring、springmvc、springboot、springcloud、mybatis" class="headerlink" title="开源框架spring、springmvc、springboot、springcloud、mybatis"></a><strong>开源框架spring、springmvc、springboot、springcloud、mybatis</strong></h3><ul>
<li><h4 id="对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"><a href="#对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。" class="headerlink" title="对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"></a>对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。</h4><p>  Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，因为通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。<br>  Spring的优点：</p>
<ol>
<li>降低了组件之间的耦合性，实现了软件各层之间的解耦。</li>
<li>可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。</li>
<li>容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。<br>Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。面向切面编程中还要理解切入点、切面、通知、织入等概念。<br>Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。</li>
</ol>
</li>
<li><h4 id="为什么要使用spring？"><a href="#为什么要使用spring？" class="headerlink" title="为什么要使用spring？"></a>为什么要使用spring？</h4><ol>
<li><strong>简介</strong><br>目的：解决企业应用开发的复杂性<br>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br>范围：任何Java应用<br>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</li>
<li><strong>轻量</strong>　　<br>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</li>
<li><strong>控制反转</strong>　　<br>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
<li><strong>面向切面</strong>　　<br>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
<li><strong>容器</strong><br>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
<li><strong>框架</strong><br>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。<br>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</li>
</ol>
</li>
<li><h4 id="解释一下什么是AOP？"><a href="#解释一下什么是AOP？" class="headerlink" title="解释一下什么是AOP？"></a>解释一下什么是AOP？</h4><p>  AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>  而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。<br>  使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。” </p>
</li>
<li><h4 id="解释一下什么是IOC？"><a href="#解释一下什么是IOC？" class="headerlink" title="解释一下什么是IOC？"></a>解释一下什么是IOC？</h4><p>  IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。<br>  1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。<br>  IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：<br>  图 IOC解耦过程<br>  大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。<br>  我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：<br>  图 拿掉IOC容器后的系统<br>  我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！<br>  我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：<br>  软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>  软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>  通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
</li>
<li><h4 id="spring有哪些主要模块？"><a href="#spring有哪些主要模块？" class="headerlink" title="spring有哪些主要模块？"></a>spring有哪些主要模块？</h4><p>  Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>
</li>
<li><h4 id="spring常用的注入方式有哪些？"><a href="#spring常用的注入方式有哪些？" class="headerlink" title="spring常用的注入方式有哪些？"></a>spring常用的注入方式有哪些？</h4><p>  Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>
<ul>
<li>构造方法注入</li>
<li>setter注入</li>
<li>基于注解的注入</li>
</ul>
</li>
<li><h4 id="spring中的bean是线程安全的吗？"><a href="#spring中的bean是线程安全的吗？" class="headerlink" title="spring中的bean是线程安全的吗？"></a>spring中的bean是线程安全的吗？</h4><p>  Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>
</li>
<li><h4 id="spring支持几种bean的作用域？"><a href="#spring支持几种bean的作用域？" class="headerlink" title="spring支持几种bean的作用域？"></a>spring支持几种bean的作用域？</h4><p>  当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>
<ul>
<li><p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</p>
</li>
<li><p>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</p>
</li>
<li><p>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
<li><p>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
<li><p>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</p>
<p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。<br>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>
</li>
</ul>
</li>
<li><h4 id="spring自动装配bean有哪些方式？"><a href="#spring自动装配bean有哪些方式？" class="headerlink" title="spring自动装配bean有哪些方式？"></a>spring自动装配bean有哪些方式？</h4><p>  Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。<br>  spring中bean装配有两种方式：</p>
<ul>
<li><p>隐式的bean发现机制和自动装配</p>
</li>
<li><p>在java代码或者XML中进行显示配置</p>
<p>当然这些方式也可以配合使用。</p>
</li>
</ul>
</li>
<li><h4 id="spring食物实现方式有哪些？"><a href="#spring食物实现方式有哪些？" class="headerlink" title="spring食物实现方式有哪些？"></a>spring食物实现方式有哪些？</h4><ul>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean 的声明式事务管理</li>
<li>基于 @Transactional 的声明式事务管理</li>
<li>基于 Aspectj AOP 配置事务</li>
</ul>
</li>
<li><h4 id="说一下spring的事物隔离？"><a href="#说一下spring的事物隔离？" class="headerlink" title="说一下spring的事物隔离？"></a>说一下spring的事物隔离？</h4><p>  事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>
<ul>
<li>脏读：一个事务读到另一个事务未提交的更新数据。</li>
<li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li>
<li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li>
</ul>
</li>
<li><h4 id="说一下springmvc运行流程？"><a href="#说一下springmvc运行流程？" class="headerlink" title="说一下springmvc运行流程？"></a>说一下springmvc运行流程？</h4><p>  Spring MVC运行流程图：<br>  Spring运行流程描述：</p>
<ol>
<li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<ol start="5">
<li>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li>
<li>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li>
<li>ViewResolver 结合Model和View，来渲染视图；</li>
<li>将渲染结果返回给客户端。</li>
</ol>
</li>
<li><h4 id="springMVC有哪些组件？"><a href="#springMVC有哪些组件？" class="headerlink" title="springMVC有哪些组件？"></a>springMVC有哪些组件？</h4><p>  Spring MVC的核心组件：</p>
<ul>
<li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li>
<li>Controller：具体处理请求的控制器</li>
<li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li>
<li>ModelAndView：服务层返回的数据和视图层的封装类</li>
<li>ViewResolver：视图解析器，解析具体的视图</li>
<li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li>
</ul>
</li>
<li><h4 id="常用注解有哪些？起什么作用？"><a href="#常用注解有哪些？起什么作用？" class="headerlink" title="常用注解有哪些？起什么作用？"></a>常用注解有哪些？起什么作用？</h4><ul>
<li>@RequestMapping<br>  RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>  RequestMapping注解有六个属性，下面我们把她分成三类进行说明。<br>  value， method：<ul>
<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li>
<li>method：指定请求的method类型， GET、POST、PUT、DELETE等；<br>consumes，produces</li>
<li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li>
<li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>params，headers</li>
<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>
<li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
</ul>
</li>
<li>@Autowired</li>
</ul>
</li>
<li><h4 id="什么是springboot？"><a href="#什么是springboot？" class="headerlink" title="什么是springboot？"></a>什么是springboot？</h4><p>  在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<bean>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。<br>  SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p>
</li>
<li><h4 id="为什么要用springboot？"><a href="#为什么要用springboot？" class="headerlink" title="为什么要用springboot？"></a>为什么要用springboot？</h4><ul>
<li>Spring Boot使编码变简单</li>
<li>Spring Boot使配置变简单</li>
<li>Spring Boot使部署变简单</li>
<li>Spring Boot使监控变简单</li>
<li>Spring的不足</li>
</ul>
</li>
<li><h4 id="springboot核心配置文件是什么？"><a href="#springboot核心配置文件是什么？" class="headerlink" title="springboot核心配置文件是什么？"></a>springboot核心配置文件是什么？</h4><p>  Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
</li>
<li><h4 id="springboot配置文件有哪几种类型？它们有什么区别？"><a href="#springboot配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="springboot配置文件有哪几种类型？它们有什么区别？"></a>springboot配置文件有哪几种类型？它们有什么区别？</h4><p>  Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</p>
</li>
<li><h4 id="springboot有哪些方式可以实现热部署？"><a href="#springboot有哪些方式可以实现热部署？" class="headerlink" title="springboot有哪些方式可以实现热部署？"></a>springboot有哪些方式可以实现热部署？</h4><p>  SpringBoot热部署实现有两种方式：<br>  ①. 使用spring loaded<br>  在项目中添加如下代码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;!-- springBoot编译插件--&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;dependencies&gt;</span><br><span class="line">                &lt;!-- spring热部署 --&gt;</span><br><span class="line">                &lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;1.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;/dependency&gt;</span><br><span class="line">            &lt;/dependencies&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>  添加完毕后需要使用mvn指令运行：<br>  首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的”+”,然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）<br>  点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可<br>  ②. 使用spring-boot-devtools<br>  在项目的pom文件中添加依赖：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--热部署jar--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>  然后：使用 shift+ctrl+alt+”/“ （IDEA中的快捷键） 选择”Registry” 然后勾选 compiler.automake.allow.when.app.running</p>
</li>
<li><h4 id="什么是springcloud？"><a href="#什么是springcloud？" class="headerlink" title="什么是springcloud？"></a>什么是springcloud？</h4><p>  从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。<br>  Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。<br>  Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
<li>……<br>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</li>
</ul>
</li>
<li><h4 id="springcloud断路器的作用是什么？"><a href="#springcloud断路器的作用是什么？" class="headerlink" title="springcloud断路器的作用是什么？"></a>springcloud断路器的作用是什么？</h4><p>  在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。<br>  断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p>
</li>
<li><h4 id="springcloud的核心组件有哪些？"><a href="#springcloud的核心组件有哪些？" class="headerlink" title="springcloud的核心组件有哪些？"></a>springcloud的核心组件有哪些？</h4><p>  ①. 服务发现——Netflix Eureka<br>  一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。<br>  ②. 客服端负载均衡——Netflix Ribbon<br>  Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。<br>  ③. 断路器——Netflix Hystrix<br>  断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。<br>  ④. 服务网关——Netflix Zuul<br>  类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。<br>  ⑤. 分布式配置——Spring Cloud Config<br>  这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
</li>
<li><h4 id="什么是ORM框架？"><a href="#什么是ORM框架？" class="headerlink" title="什么是ORM框架？"></a>什么是ORM框架？</h4><p>  对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
</li>
<li><h4 id="mybatis中-和-P-的区别是什么？"><a href="#mybatis中-和-P-的区别是什么？" class="headerlink" title="mybatis中#{}和$P{}的区别是什么？"></a>mybatis中#{}和$P{}的区别是什么？</h4><ul>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>Mybatis在处理${}时，就是把${}替换成变量的值；</li>
<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ul>
</li>
<li><h4 id="mybatis有几种分页方式？"><a href="#mybatis有几种分页方式？" class="headerlink" title="mybatis有几种分页方式？"></a>mybatis有几种分页方式？</h4><ul>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ul>
</li>
<li><h4 id="mybatis逻辑分页核物理分切的区别是什么？"><a href="#mybatis逻辑分页核物理分切的区别是什么？" class="headerlink" title="mybatis逻辑分页核物理分切的区别是什么？"></a>mybatis逻辑分页核物理分切的区别是什么？</h4><ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
</li>
<li><h4 id="mybatis是否支持延迟加载？延迟加载的原理是什么？"><a href="#mybatis是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="mybatis是否支持延迟加载？延迟加载的原理是什么？"></a>mybatis是否支持延迟加载？延迟加载的原理是什么？</h4><p>  Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。<br>  它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。<br>  当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
</li>
<li><h4 id="说一下mybatis的一级缓存和二级缓存？"><a href="#说一下mybatis的一级缓存和二级缓存？" class="headerlink" title="说一下mybatis的一级缓存和二级缓存？"></a>说一下mybatis的一级缓存和二级缓存？</h4><p>  一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。<br>  二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；<br>  对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</li>
<li><h4 id="mybatis有哪些执行器？"><a href="#mybatis有哪些执行器？" class="headerlink" title="mybatis有哪些执行器？"></a>mybatis有哪些执行器？</h4><p>  Mybatis有三种基本的执行器（Executor）：</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ul>
</li>
<li><h4 id="mybatis分页插件的实现原理是什么？"><a href="#mybatis分页插件的实现原理是什么？" class="headerlink" title="mybatis分页插件的实现原理是什么？"></a>mybatis分页插件的实现原理是什么？</h4><p>  分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
</li>
<li><h4 id="mybatis如何编写一个自定义插件？"><a href="#mybatis如何编写一个自定义插件？" class="headerlink" title="mybatis如何编写一个自定义插件？"></a>mybatis如何编写一个自定义插件？</h4><p>  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为： </p>
<ul>
<li>Executor：拦截执行器的方法(log记录) </li>
<li>StatementHandler ：拦截Sql语法构建的处理 </li>
<li>ParameterHandler ：拦截参数的处理 </li>
<li>ResultSetHandler ：拦截结果集的处理<br>Mybatis自定义插件必须实现Interceptor接口：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">    Object intercept(Invocation invocation) throws Throwable;</span><br><span class="line">    Object plugin(Object target);</span><br><span class="line">    void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
intercept方法：拦截器具体处理逻辑方法<br>plugin方法：根据签名signatureMap生成动态代理对象<br>setProperties方法：设置Properties属性<br>自定义插件demo：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ExamplePlugin.java</span><br><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">    type= Executor.class,</span><br><span class="line">    method = &quot;update&quot;,</span><br><span class="line">    args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    Object target = invocation.getTarget(); //被代理对象</span><br><span class="line">    Method method = invocation.getMethod(); //代理方法</span><br><span class="line">    Object[] args = invocation.getArgs(); //方法参数</span><br><span class="line">    // do something ...... 方法拦截前执行代码块</span><br><span class="line">    Object result = invocation.proceed();</span><br><span class="line">    // do something .......方法拦截后执行代码块</span><br><span class="line">    return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： </li>
<li>type：表示拦截的类，这里是Executor的实现类；</li>
<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>
<li>args：表示方法参数。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——NOSQL</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BNOSQL/</url>
    <content><![CDATA[<h3 id="redis-memecache"><a href="#redis-memecache" class="headerlink" title="redis/memecache"></a><strong>redis/memecache</strong></h3><ul>
<li><h4 id="redis是什么？都有哪些使用场景？"><a href="#redis是什么？都有哪些使用场景？" class="headerlink" title="redis是什么？都有哪些使用场景？"></a>redis是什么？都有哪些使用场景？</h4><p>  Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>  Redis 使用场景：</p>
<ul>
<li>数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对扩展性要求高的数据</li>
</ul>
</li>
<li><h4 id="redis有哪些功能？"><a href="#redis有哪些功能？" class="headerlink" title="redis有哪些功能？"></a>redis有哪些功能？</h4><ul>
<li>数据缓存功能</li>
<li>分布式锁的功能</li>
<li>支持数据持久化</li>
<li>支持事务</li>
<li>支持消息队列</li>
</ul>
</li>
<li><h4 id="redis和memecache有什么区别？"><a href="#redis和memecache有什么区别？" class="headerlink" title="redis和memecache有什么区别？"></a>redis和memecache有什么区别？</h4><ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
</ul>
</li>
<li><h4 id="redis为什么是单线程的？"><a href="#redis为什么是单线程的？" class="headerlink" title="redis为什么是单线程的？"></a>redis为什么是单线程的？</h4><p>  因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>  关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。<br>  而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
</li>
<li><h4 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h4><ul>
<li>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</li>
<li>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>
</ul>
</li>
<li><h4 id="redis支持的数据类型有哪些？"><a href="#redis支持的数据类型有哪些？" class="headerlink" title="redis支持的数据类型有哪些？"></a>redis支持的数据类型有哪些？</h4><p>  string、list、hash、set、zset。</p>
</li>
<li><h4 id="redis支持的java客户端都有哪些？"><a href="#redis支持的java客户端都有哪些？" class="headerlink" title="redis支持的java客户端都有哪些？"></a>redis支持的java客户端都有哪些？</h4><p>  Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
</li>
<li><h4 id="jedis和redisson有哪些区别？"><a href="#jedis和redisson有哪些区别？" class="headerlink" title="jedis和redisson有哪些区别？"></a>jedis和redisson有哪些区别？</h4><p>  Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。<br>  Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</li>
<li><h4 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h4><ul>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li>
</ul>
</li>
<li><h4 id="redis持久化有几种方式？"><a href="#redis持久化有几种方式？" class="headerlink" title="redis持久化有几种方式？"></a>redis持久化有几种方式？</h4><p>  Redis 的持久化有两种方式，或者说有两种策略：</p>
<ul>
<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li>
</ul>
</li>
<li><h4 id="redis怎么实现分布式锁？"><a href="#redis怎么实现分布式锁？" class="headerlink" title="redis怎么实现分布式锁？"></a>redis怎么实现分布式锁？</h4><p>  Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。<br>  占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
</li>
<li><h4 id="redis分布式锁有什么缺陷？"><a href="#redis分布式锁有什么缺陷？" class="headerlink" title="redis分布式锁有什么缺陷？"></a>redis分布式锁有什么缺陷？</h4><p>  Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
</li>
<li><h4 id="redis如何做内存优化？"><a href="#redis如何做内存优化？" class="headerlink" title="redis如何做内存优化？"></a>redis如何做内存优化？</h4><p>  尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。<br>  比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
</li>
<li><h4 id="redis淘汰策略有哪些？"><a href="#redis淘汰策略有哪些？" class="headerlink" title="redis淘汰策略有哪些？"></a>redis淘汰策略有哪些？</h4><ul>
<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>
<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>
<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
</li>
<li><h4 id="redis常见的性能问题有哪些？该如何解决？"><a href="#redis常见的性能问题有哪些？该如何解决？" class="headerlink" title="redis常见的性能问题有哪些？该如何解决？"></a>redis常见的性能问题有哪些？该如何解决？</h4><ul>
<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>
<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——MySQL</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BMySQL/</url>
    <content><![CDATA[<h3 id="数据库-mysql"><a href="#数据库-mysql" class="headerlink" title="数据库 mysql"></a><strong>数据库 mysql</strong></h3><ul>
<li><h4 id="Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入？"><a href="#Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入？" class="headerlink" title="Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入？"></a>Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入？</h4><ol>
<li>PreparedStatement支持动态设置参数，Statement不支持。</li>
<li>PreparedStatement可避免如类似 单引号 的编码麻烦，Statement不可以。</li>
<li>PreparedStatement支持预编译，Statement不支持。</li>
<li>在SQL语句出错时PreparedStatement不易检查，而Statement则更便于查错。</li>
<li>PreparedStatement可防止SQL助于，更加安全，而Statement不行。</li>
</ol>
<p>  <strong>补充说明:</strong>什么是SQL注入以及应对策略： 通过SQL语句的拼接达到无参数查询数据库数据目的的方法。如将要执行的SQL语句为 select * from table where name = “+appName+”，利用appName参数值的输入，来生成恶意的SQL语句，如将[‘or’1’=‘1’] 传入可在数据库中执行。因此可以采用PrepareStatement来避免SQL注入，在服务器端接收参数数据后，进行验证，此时PrepareStatement会自动检测，而Statement不行，需要手工检测。</p>
</li>
<li><h4 id="如何避免-sql-注入？"><a href="#如何避免-sql-注入？" class="headerlink" title="如何避免 sql 注入？"></a>如何避免 sql 注入？</h4><ul>
<li>PreparedStatement（简单又有效的方法）</li>
<li>使用正则表达式过滤传入的参数</li>
<li>字符串过滤</li>
<li>JSP中调用该函数检查是否包函非法字符</li>
<li>JSP页面判断代码</li>
</ul>
</li>
<li><h4 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h4><ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性</li>
</ul>
</li>
<li><h4 id="一张自增表里面总共有7条数据，删除了最后2条数据，重启mysql数据库，又插入了1条数据，此时id是几？"><a href="#一张自增表里面总共有7条数据，删除了最后2条数据，重启mysql数据库，又插入了1条数据，此时id是几？" class="headerlink" title="一张自增表里面总共有7条数据，删除了最后2条数据，重启mysql数据库，又插入了1条数据，此时id是几？"></a>一张自增表里面总共有7条数据，删除了最后2条数据，重启mysql数据库，又插入了1条数据，此时id是几？</h4><ul>
<li>表类型如果是 MyISAM ，那 id 就是 18。</li>
<li>表类型如果是 InnoDB，那 id 就是 15。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</li>
</ul>
</li>
<li><h4 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h4><p>  使用 select version() 获取当前 MySQL 数据库版本。</p>
</li>
<li><h4 id="说一下ACID是什么？"><a href="#说一下ACID是什么？" class="headerlink" title="说一下ACID是什么？"></a>说一下ACID是什么？</h4><ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</li>
<li><h4 id="char和varchar的区别是什么？"><a href="#char和varchar的区别是什么？" class="headerlink" title="char和varchar的区别是什么？"></a>char和varchar的区别是什么？</h4><p>  char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>  chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>  varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>  所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
</li>
<li><h4 id="float和double的区别是什么？"><a href="#float和double的区别是什么？" class="headerlink" title="float和double的区别是什么？"></a>float和double的区别是什么？</h4><ul>
<li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li>
<li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li>
</ul>
</li>
<li><h4 id="mysql的内连接、左链接、右链接有什么区别？"><a href="#mysql的内连接、左链接、右链接有什么区别？" class="headerlink" title="mysql的内连接、左链接、右链接有什么区别？"></a>mysql的内连接、左链接、右链接有什么区别？</h4><ul>
<li>内连接关键字：inner join；左连接：left join；右连接：right join。</li>
<li>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</li>
</ul>
</li>
<li><h4 id="mysql索引是怎么实现的？"><a href="#mysql索引是怎么实现的？" class="headerlink" title="mysql索引是怎么实现的？"></a>mysql索引是怎么实现的？</h4><p>  索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>  具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
</li>
<li><h4 id="怎么验证MySQL的索引是否满足需求？"><a href="#怎么验证MySQL的索引是否满足需求？" class="headerlink" title="怎么验证MySQL的索引是否满足需求？"></a>怎么验证MySQL的索引是否满足需求？</h4><p>  使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>  explain 语法：explain select * from table where type=1。</p>
</li>
<li><h4 id="说一下数据库的事物隔离？"><a href="#说一下数据库的事物隔离？" class="headerlink" title="说一下数据库的事物隔离？"></a>说一下数据库的事物隔离？</h4><p>  MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ<br>  可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<ul>
<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>
<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>
<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li>
</ul>
</li>
<li><h4 id="说一下mysql常用的引擎？"><a href="#说一下mysql常用的引擎？" class="headerlink" title="说一下mysql常用的引擎？"></a>说一下mysql常用的引擎？</h4><ul>
<li>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li>
<li>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li>
</ul>
</li>
<li><h4 id="说一下mysql的行锁和表锁？"><a href="#说一下mysql的行锁和表锁？" class="headerlink" title="说一下mysql的行锁和表锁？"></a>说一下mysql的行锁和表锁？</h4><p>  MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<ul>
<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
</li>
<li><h4 id="说一下乐观锁和悲观锁？"><a href="#说一下乐观锁和悲观锁？" class="headerlink" title="说一下乐观锁和悲观锁？"></a>说一下乐观锁和悲观锁？</h4><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</li>
</ul>
</li>
<li><h4 id="MySQL问题排查都有哪些手段？"><a href="#MySQL问题排查都有哪些手段？" class="headerlink" title="MySQL问题排查都有哪些手段？"></a>MySQL问题排查都有哪些手段？</h4><ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL</li>
</ul>
</li>
<li><h4 id="如何做MySQL的性能优化？"><a href="#如何做MySQL的性能优化？" class="headerlink" title="如何做MySQL的性能优化？"></a>如何做MySQL的性能优化？</h4><ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——Java进阶</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BJAVA%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h3 id="并发、多线程"><a href="#并发、多线程" class="headerlink" title="并发、多线程"></a><strong>并发、多线程</strong></h3><ul>
<li><h4 id="线程同步，并发操作怎么控制？"><a href="#线程同步，并发操作怎么控制？" class="headerlink" title="线程同步，并发操作怎么控制？"></a>线程同步，并发操作怎么控制？</h4><p>  Java中可在方法名前加关键字syschronized来处理当有多个线程同时访问共享资源时候的问题。syschronized相当于一把锁，当有申请者申请该资源时，如果该资源没有被占用，那么将资源交付给这个申请者使用，在此期间，其他申请者只能申请而不能使用该资源，当该资源被使用完成后将释放该资源上的锁，其他申请者可申请使用。并发控制主要是为了多线程操作时带来的资源读写问题。如果不加以空间可能会出现死锁，读脏数据、不可重复读、丢失更新等异常。</p>
<p>  并发操作可以通过加锁的方式进行控制，锁又可分为乐观锁和悲观锁。<br>  <strong>悲观锁：</strong><br>  悲观锁并发模式假定系统中存在足够多的数据修改操作，以致于任何确定的读操作都可能会受到由个别的用户所制造的数据修改的影响。也就是说悲观锁假定冲突总会发生，通过独占正在被读取的数据来避免冲突。但是独占数据会导致其他进程无法修改该数据，进而产生阻塞，读数据和写数据会相互阻塞。<br>  <strong>乐观锁：</strong><br>  乐观锁假定系统的数据修改只会产生非常少的冲突，也就是说任何进程都不大可能修改别的进程正在访问的数据。乐观并发模式下，读数据和写数据之间不会发生冲突，只有写数据与写数据之间会发生冲突。即读数据不会产生阻塞，只有写数据才会产生阻塞。<br>  <strong>注意：</strong>最后的几个问题又回到了Java内存模型以及进程、线程的底层知识上，其实无论是对于Java网络编程也好，还是对于Java框架的使用也好，这都离不开Java语言底层的技术支撑，因此了解底层知识是做好优化的重中之重。</p>
</li>
<li><h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>
<li>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</li>
</ul>
</li>
<li><h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><ul>
<li>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。<br>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。<br>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</li>
</ul>
</li>
<li><h4 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h4><ul>
<li>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</li>
</ul>
</li>
<li><h4 id="创建线程有哪些方式？"><a href="#创建线程有哪些方式？" class="headerlink" title="创建线程有哪些方式？"></a>创建线程有哪些方式？</h4><p>  ①. 继承Thread类创建线程类<br>  定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>  创建Thread子类的实例，即创建了线程对象。<br>  调用线程对象的start()方法来启动该线程。<br>  ②. 通过Runnable接口创建线程类<br>  定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>  创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>  调用线程对象的start()方法来启动该线程。<br>  ③. 通过Callable和Future创建线程<br>  创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>  创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>  使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>  调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
</li>
<li><h4 id="说一下runnable和callable有什么区别？"><a href="#说一下runnable和callable有什么区别？" class="headerlink" title="说一下runnable和callable有什么区别？"></a>说一下runnable和callable有什么区别？</h4><p>  有点深的问题了，也看出一个Java程序员学习知识的广度。</p>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
</ul>
</li>
<li><h4 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h4><p>  线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>
<li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>
<li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>
<li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h4><ul>
<li>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</li>
<li>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</li>
</ul>
</li>
<li><h4 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h4><ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
</li>
<li><h4 id="线程run-和start-有什么区别？"><a href="#线程run-和start-有什么区别？" class="headerlink" title="线程run()和start()有什么区别？"></a>线程run()和start()有什么区别？</h4><ul>
<li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</li>
<li>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li>
<li>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</li>
</ul>
</li>
<li><h4 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h4><p>  ①. newFixedThreadPool(int nThreads)<br>  创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。<br>  ②. newCachedThreadPool()<br>  创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。<br>  ③. newSingleThreadExecutor()<br>  这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。<br>  ④. newScheduledThreadPool(int corePoolSize)<br>  创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
</li>
<li><h4 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h4><p>  线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。<br>  线程池各个状态切换框架图：</p>
</li>
<li><h4 id="线程池中submit-和-execute-方法有什么区别？"><a href="#线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别？"></a>线程池中submit() 和 execute()方法有什么区别？</h4><ul>
<li>接收的参数不一样</li>
<li>submit有返回值，而execute没有</li>
<li>submit方便Exception处理</li>
</ul>
</li>
<li><h4 id="在java程序中怎么保证多线程的运行安全？"><a href="#在java程序中怎么保证多线程的运行安全？" class="headerlink" title="在java程序中怎么保证多线程的运行安全？"></a>在java程序中怎么保证多线程的运行安全？</h4><p>  线程安全在三个方面体现：</p>
<ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>
</ul>
</li>
<li><h4 id="多线程锁的升级原理是什么？"><a href="#多线程锁的升级原理是什么？" class="headerlink" title="多线程锁的升级原理是什么？"></a>多线程锁的升级原理是什么？</h4><p>  在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。<br>  锁升级的图示过程： </p>
</li>
<li><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>  死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p>
</li>
<li><h4 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h4><p>  死锁的四个必要条件：</p>
<ul>
<li><p>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</p>
</li>
<li><p>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</p>
</li>
<li><p>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
</li>
<li><p>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。<br>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。<br>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。<br>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
</li>
</ul>
</li>
<li><h4 id="ThreadLocal是什么？有哪些使用场景？"><a href="#ThreadLocal是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal是什么？有哪些使用场景？"></a>ThreadLocal是什么？有哪些使用场景？</h4><p>  线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
</li>
<li><h4 id="说一下synchronized底层实现原理？"><a href="#说一下synchronized底层实现原理？" class="headerlink" title="说一下synchronized底层实现原理？"></a>说一下synchronized底层实现原理？</h4><p>  synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。<br>  Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<pre><code>- 普通同步方法，锁是当前实例对象
- 静态同步方法，锁是当前类的class对象
- 同步方法块，锁是括号里面的对象</code></pre></li>
<li><h4 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h4><ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
</ul>
</li>
<li><h4 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h4><ul>
<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li>
</ul>
</li>
<li><h4 id="synchronized-和-ReentrantLock区别是什么？"><a href="#synchronized-和-ReentrantLock区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock区别是什么？"></a>synchronized 和 ReentrantLock区别是什么？</h4><p>  synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： </p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</li>
</ul>
</li>
<li><h4 id="说一下atomic的原理。"><a href="#说一下atomic的原理。" class="headerlink" title="说一下atomic的原理。"></a>说一下atomic的原理。</h4><p>  Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。<br>  Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h3><ul>
<li><h4 id="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"><a href="#关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。" class="headerlink" title="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"></a>关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。</h4><p>  由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果 属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份。</p>
</li>
<li><h4 id="反射讲一讲，主要是概念-都在哪需要反射机制，反射的性能，如何优化？"><a href="#反射讲一讲，主要是概念-都在哪需要反射机制，反射的性能，如何优化？" class="headerlink" title="反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化？"></a>反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化？</h4><p>  反射机制的定义：<br>  是在运行状态中，对于任意的一个类，都能够知道这个类的所有属性和方法，对任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息及动态调用类对象方法的功能称为java的反射机制。<br>  反射的作用：</p>
<ol>
<li>动态地创建类的实例，将类绑定到现有的对象中，或从现有的对象中获取类型。</li>
<li>应用程序需要在运行时从某个特定的程序集中载入一个特定的类。</li>
</ol>
</li>
<li><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>  反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力<br>  Java反射：<br>  在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法<br>  Java反射机制主要提供了以下功能：</p>
<pre><code>- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法。 </code></pre></li>
<li><h4 id="什么事java序列化？什么情况下需要序列化？"><a href="#什么事java序列化？什么情况下需要序列化？" class="headerlink" title="什么事java序列化？什么情况下需要序列化？"></a>什么事java序列化？什么情况下需要序列化？</h4><p>  简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br>  什么情况下需要序列化：</p>
<ul>
<li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>当你想用套接字在网络上传送对象的时候；</li>
<li>当你想通过RMI传输对象的时候；</li>
</ul>
</li>
<li><h4 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h4><ul>
<li>动态代理：<br>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</li>
<li>动态代理的应用：<ul>
<li>Spring的AOP</li>
<li>加事务</li>
<li>加权限</li>
<li>加日志</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h4><p>  首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>
</li>
</ul>
<h3 id="java-web"><a href="#java-web" class="headerlink" title="java web"></a><strong>java web</strong></h3><ul>
<li><h4 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h4><p>  大致分为4部：Servlet类加载–&gt;实例化–&gt;服务–&gt;销毁<br>  Tomcat中Servlet的时序图如下所示：待导入</p>
<ol>
<li>Web Client向Servlet容器(Tomcat)发出HTTP请求。</li>
<li>Servlet容器接收Client端的请求。</li>
<li>Servlet容器创建一个HttpRequest对象，将Client的请求信息封装到这个对象中。</li>
<li>Servlet创建一个HttpResponse对象。</li>
<li>Servlet调用HttpServlet对象的service方法，把HttpRequest对象和HttpResponse对象作为参数传递给HttpServlet对象中。</li>
<li>HttpServlet调用HttpRequest对象的方法，获取Http请求，并进行相应处理。</li>
<li>处理完成HttpServlet调用HttpResponse对象的方法，返回响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传回客户端。<br>其中的3个方法说明了Servlet的生命周期：</li>
<li>init()：负责初始化Servlet对象。</li>
<li>service()：负责响应客户端请求。</li>
<li>destroy()：当Servlet对象推出时，负责释放占用资源。</li>
</ol>
</li>
<li><h4 id="session-和-cookie-有什么区别？"><a href="#session-和-cookie-有什么区别？" class="headerlink" title="session 和 cookie 有什么区别？"></a>session 和 cookie 有什么区别？</h4><ol>
<li>Session由应用服务器维护的一个服务器端的存储空间；Cookie是客户端的存储空间，由浏览器维护。</li>
<li>用户可以通过浏览器设置决定是否保存Cookie，而不能决定是否保存Session，因为Session是由服务器端维护的。</li>
<li>Session中保存的是对象，Cookie中保存的是字符串。</li>
<li>Session和Cookie不能跨窗口使用，每打开一个浏览器系统会赋予一个SessionID，此时的SessionID不同，若要完成跨浏览器访问数据，可以使用 Application。</li>
<li>Session、Cookie都有失效时间，过期后会自动删除，减少系统开销。</li>
</ol>
<ul>
<li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li>
<li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li>
<li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li>
</ul>
</li>
<li><h4 id="说一下session的工作原理？"><a href="#说一下session的工作原理？" class="headerlink" title="说一下session的工作原理？"></a>说一下session的工作原理？</h4><p>  其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。</p>
</li>
<li><h4 id="如果客户端禁止cookie能实现session吗？还能用吗？"><a href="#如果客户端禁止cookie能实现session吗？还能用吗？" class="headerlink" title="如果客户端禁止cookie能实现session吗？还能用吗？"></a>如果客户端禁止cookie能实现session吗？还能用吗？</h4><ul>
<li>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</li>
<li>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：<ul>
<li>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“–enable-trans-sid”选项，让PHP自动跨页传递Session ID。</li>
<li>手动通过URL传值、隐藏表单传递Session ID。</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="什么是XSS攻击，如何避免？"><a href="#什么是XSS攻击，如何避免？" class="headerlink" title="什么是XSS攻击，如何避免？"></a>什么是XSS攻击，如何避免？</h4><p>  XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。<br>  XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p>
</li>
<li><h4 id="什么是CSRF攻击，如何避免？"><a href="#什么是CSRF攻击，如何避免？" class="headerlink" title="什么是CSRF攻击，如何避免？"></a>什么是CSRF攻击，如何避免？</h4><ul>
<li>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</li>
<li>如何避免：<ol>
<li>验证 HTTP Referer 字段<br>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF<br>攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</li>
<li>使用验证码<br>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</li>
<li>在请求地址中添加token并验证<br>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。<br>对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a><br>而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把token以参数的形式加入请求了。</li>
<li>在HTTP 头中自定义属性并验证<br>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h3><ul>
<li><h4 id="throw-和-throws-的区别？"><a href="#throw-和-throws-的区别？" class="headerlink" title="throw 和 throws 的区别？"></a>throw 和 throws 的区别？</h4><p>  throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p>
</li>
<li><h4 id="final、finally、finalize有什么区别？"><a href="#final、finally、finalize有什么区别？" class="headerlink" title="final、finally、finalize有什么区别？"></a>final、finally、finalize有什么区别？</h4><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾</li>
</ul>
</li>
<li><h4 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h4><ul>
<li>答：catch 可以省略</li>
<li>原因：<br>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。<br>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。<br>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</li>
</ul>
</li>
<li><h4 id="try-catch-finally中，如果catch中return了，finally还会执行吗？"><a href="#try-catch-finally中，如果catch中return了，finally还会执行吗？" class="headerlink" title="try-catch-finally中，如果catch中return了，finally还会执行吗？"></a>try-catch-finally中，如果catch中return了，finally还会执行吗？</h4><p>  答：会执行，在 return 前执行<br>  代码示例1：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？</span><br><span class="line">*/</span><br><span class="line">public class FinallyDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getInt() &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(a / 0);</span><br><span class="line">            a = 20;</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            a = 30;</span><br><span class="line">            return a;</span><br><span class="line">            /*</span><br><span class="line">            * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span><br><span class="line">            * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span><br><span class="line">            * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span><br><span class="line">            */</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            a = 40;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//      return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  执行结果：30</p>
<p>  代码示例2：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java_02;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？</span><br><span class="line">*/</span><br><span class="line">public class FinallyDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getInt() &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(a / 0);</span><br><span class="line">            a = 20;</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            a = 30;</span><br><span class="line">            return a;</span><br><span class="line">            /*</span><br><span class="line">            * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span><br><span class="line">            * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span><br><span class="line">            * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span><br><span class="line">            */</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            a = 40;</span><br><span class="line">            return a; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//      return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  执行结果：40</p>
</li>
<li><h4 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h4><ul>
<li>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</li>
<li>SQLException：提供关于数据库访问错误或其他错误信息的异常。</li>
<li>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 </li>
<li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>
<li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 </li>
<li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li>
<li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li>
<li>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>
</ul>
</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h3><ul>
<li><h4 id="HTTP-报文包含内容"><a href="#HTTP-报文包含内容" class="headerlink" title="HTTP 报文包含内容"></a>HTTP 报文包含内容</h4><p>  <strong>主要包含四部分：</strong></p>
<ol>
<li>request line</li>
<li>header line</li>
<li>blank line</li>
<li>request body</li>
</ol>
<p>  <strong>注意：</strong>上面的三个问题是网络编程的基础知识问题，作为Java工程师也需要掌握HTTP的知识，而如今HTTPS同样也成为了标准，也需要大家进一步了解。此外，相对于大家在课本或者课堂中所学习的HTTP 1.0/1.1这些协议而言，很多公司已经迈入了HTTP 2.0时代，因此两者之间的差别也需要我们进一步了解。</p>
</li>
<li><h4 id="http响应码301和302代表的是什么？有什么区别？"><a href="#http响应码301和302代表的是什么？有什么区别？" class="headerlink" title="http响应码301和302代表的是什么？有什么区别？"></a>http响应码301和302代表的是什么？有什么区别？</h4><p>  301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。<br>  区别： </p>
<ul>
<li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li>
<li>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</li>
</ul>
</li>
<li><h4 id="froward-和-redirect-的区别？"><a href="#froward-和-redirect-的区别？" class="headerlink" title="froward 和 redirect 的区别？"></a>froward 和 redirect 的区别？</h4><ul>
<li>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</li>
<li>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</li>
<li>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。<br>举个通俗的例子：</li>
<li>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</li>
<li>间接转发就相当于：”A找B借钱，B说没有，让A去找C借”。</li>
</ul>
</li>
<li><h4 id="sendRedirect-foward区别"><a href="#sendRedirect-foward区别" class="headerlink" title="sendRedirect, foward区别"></a>sendRedirect, foward区别</h4><ol>
<li>foward是服务器端控制页面转向，在客户端的浏览器地址中不会显示转向后的地址；sendRedirect则是完全的跳转，浏览器中会显示跳转的地址并重新发送请求链接。原理：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后再将这些内容返回给浏览器，浏览器根本不知道服务器发送的这些内容是从哪来的，所以地址栏还是原来的地址。</li>
<li>redirect是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求的那个地址，浏览器会用刚才的所有参数重新发送新的请求。</li>
</ol>
<p>  <strong>注意：</strong>以上的三个问题在之前网络相关的知识上更进一步，上升到了Java网络编程的相关知识，这部分意在考察面试者对于Java网络编程相关知识的掌握程度。</p>
</li>
<li><h4 id="简述tcp和udp的区别？"><a href="#简述tcp和udp的区别？" class="headerlink" title="简述tcp和udp的区别？"></a>简述tcp和udp的区别？</h4></li>
<li><h4 id="tcp为什么要三次握手，两次不行吗？为什么？"><a href="#tcp为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp为什么要三次握手，两次不行吗？为什么？"></a>tcp为什么要三次握手，两次不行吗？为什么？</h4><ul>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ul>
</li>
<li><h4 id="说一下tcp粘包是怎么产生的？"><a href="#说一下tcp粘包是怎么产生的？" class="headerlink" title="说一下tcp粘包是怎么产生的？"></a>说一下tcp粘包是怎么产生的？</h4><ul>
<li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</li>
<li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</li>
</ul>
</li>
<li><h4 id="说一下-tcp-粘包是怎么产生的？"><a href="#说一下-tcp-粘包是怎么产生的？" class="headerlink" title="说一下 tcp 粘包是怎么产生的？"></a>说一下 tcp 粘包是怎么产生的？</h4><p>  ①. 发送方产生粘包<br>  采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。<br>  ②. 接收方产生粘包<br>  接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） </p>
</li>
<li><h4 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h4><ul>
<li>应用层：网络服务与最终用户的一个接口。</li>
<li>表示层：数据的表示、安全、压缩。</li>
<li>会话层：建立、管理、终止会话。</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li>
<li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
</li>
<li><h4 id="get和post请求有哪些区别？、"><a href="#get和post请求有哪些区别？、" class="headerlink" title="get和post请求有哪些区别？、"></a>get和post请求有哪些区别？、</h4><ul>
<li><p><strong>基础知识：</strong></p>
<p>HTTP的请求格式如下:<br>主要包含三个信息：1、请求的类型（GET或POST），2、要访问的资源（如resimga.jif），3、HTTP版本（http/1.1）</p>
</li>
<li><p><strong>区别：</strong></p>
</li>
</ul>
<ol>
<li>Get是从服务器端获取数据，Post则是向服务器端发送数据。</li>
<li>在客户端，Get方式通过URL提交数据，在URL地址栏可以看到请求消息，该消息被编码过；Post数据则是放在Html header内提交。</li>
<li>对于Get方式，服务器端用Request.QueryString获取变量的值；对用Post方式，服务器端用Request.Form获取提交的数据值。</li>
<li>Get方式提交的数据最多1024字节，而Post则没有限制。</li>
<li>Get方式提交的参数及参数值会在地址栏显示，不安全，而Post不会，比较安全。</li>
</ol>
</li>
<li><h4 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h4><ul>
<li><strong>方式一：图片ping或script标签跨域</strong><br>图片ping常用于跟踪用户点击页面或动态广告曝光次数。<br>script标签可以得到从其他来源数据，这也是JSONP依赖的根据。 </li>
<li><strong>方式二：JSONP跨域</strong><br>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 &lt; script &gt;元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。<br>缺点：<br>只能使用Get请求<br>不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败<br>JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保</li>
<li><strong>方式三：CORS</strong><br>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Access-Control-Allow-Credentials&quot;: true</span><br><span class="line">// Ajax设置</span><br><span class="line">&quot;withCredentials&quot;: true</span><br></pre></td></tr></table></figure></li>
<li><strong>方式四：window.name+iframe</strong><br>window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。<br>iframe标签的跨域能力；<br>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。<br>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回&lt; iframe&gt;元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">下述用端口 </span><br><span class="line">10000表示：domainA</span><br><span class="line">10001表示：domainB</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- localhost:10000 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">iframe.style.display = &apos;none&apos;; // 隐藏</span><br><span class="line"></span><br><span class="line">var state = 0; // 防止页面无限刷新</span><br><span class="line">iframe.onload = function() &#123;</span><br><span class="line">    if(state === 1) &#123;</span><br><span class="line">        console.log(JSON.parse(iframe.contentWindow.name));</span><br><span class="line">        // 清除创建的iframe</span><br><span class="line">        iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125; else if(state === 0) &#123;</span><br><span class="line">        state = 1;</span><br><span class="line">        // 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span><br><span class="line">        // Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.</span><br><span class="line">        iframe.contentWindow.location = &apos;http://localhost:10000/proxy.html&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iframe.src = &apos;http://localhost:10001&apos;;</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- localhost:10001 --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.name = JSON.stringify(&#123;a: 1, b: 2&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>方式五：window.postMessage()</strong><br>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。<br>下述代码实现了跨域存储localStorage<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">下述用端口 </span><br><span class="line">10000表示：domainA</span><br><span class="line">10001表示：domainB</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- localhost:10000 --&gt;</span><br><span class="line">&lt;iframe src=&quot;http://localhost:10001/msg.html&quot; name=&quot;myPostMessage&quot; style=&quot;display:none;&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function main() &#123;</span><br><span class="line">    LSsetItem(&apos;test&apos;, &apos;Test: &apos; + new Date());</span><br><span class="line">    LSgetItem(&apos;test&apos;, function(value) &#123;</span><br><span class="line">        console.log(&apos;value: &apos; + value);</span><br><span class="line">    &#125;);</span><br><span class="line">    LSremoveItem(&apos;test&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var callbacks = &#123;&#125;;</span><br><span class="line">window.addEventListener(&apos;message&apos;, function(event) &#123;</span><br><span class="line">    if (event.source === frames[&apos;myPostMessage&apos;]) &#123;</span><br><span class="line">        console.log(event)</span><br><span class="line">        var data = /^#localStorage#(\d+)(null)?#([\S\s]*)/.exec(event.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            if (callbacks[data[1]]) &#123;</span><br><span class="line">                callbacks[data[1]](data[2] === &apos;null&apos; ? null : data[3]);</span><br><span class="line">            &#125;</span><br><span class="line">            delete callbacks[data[1]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">var domain = &apos;*&apos;;</span><br><span class="line">// 增加</span><br><span class="line">function LSsetItem(key, value) &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        setItem: key,</span><br><span class="line">        value: value</span><br><span class="line">    &#125;;</span><br><span class="line">    frames[&apos;myPostMessage&apos;].postMessage(JSON.stringify(obj), domain);</span><br><span class="line">&#125;</span><br><span class="line">// 获取</span><br><span class="line">function LSgetItem(key, callback) &#123;</span><br><span class="line">    var identifier = new Date().getTime();</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        identifier: identifier,</span><br><span class="line">        getItem: key</span><br><span class="line">    &#125;;</span><br><span class="line">    callbacks[identifier] = callback;</span><br><span class="line">    frames[&apos;myPostMessage&apos;].postMessage(JSON.stringify(obj), domain);</span><br><span class="line">&#125;</span><br><span class="line">// 删除</span><br><span class="line">function LSremoveItem(key) &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        removeItem: key</span><br><span class="line">    &#125;;</span><br><span class="line">    frames[&apos;myPostMessage&apos;].postMessage(JSON.stringify(obj), domain);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- localhost:10001 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.addEventListener(&apos;message&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;Receiver debugging&apos;, event);</span><br><span class="line">    if (event.origin == &apos;http://localhost:10000&apos;) &#123;</span><br><span class="line">    var data = JSON.parse(event.data);</span><br><span class="line">    if (&apos;setItem&apos; in data) &#123;</span><br><span class="line">        localStorage.setItem(data.setItem, data.value);</span><br><span class="line">    &#125; else if (&apos;getItem&apos; in data) &#123;</span><br><span class="line">        var gotItem = localStorage.getItem(data.getItem);</span><br><span class="line">        event.source.postMessage(</span><br><span class="line">        &apos;#localStorage#&apos; + data.identifier +</span><br><span class="line">        (gotItem === null ? &apos;null#&apos; : &apos;#&apos; + gotItem),</span><br><span class="line">        event.origin</span><br><span class="line">        );</span><br><span class="line">    &#125; else if (&apos;removeItem&apos; in data) &#123;</span><br><span class="line">        localStorage.removeItem(data.removeItem);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
注意Safari一下，会报错：<br>Blocked a frame with origin “<a href="http://localhost:10001”" target="_blank" rel="noopener">http://localhost:10001”</a> from accessing a frame with origin “<a href="http://localhost:10000“" target="_blank" rel="noopener">http://localhost:10000“</a>. Protocols, domains, and ports must match.<br>避免该错误，可以在Safari浏览器中勾选开发菜单==&gt;停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。</li>
<li><strong>方式六：修改document.domain跨子域</strong><br>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域<br>在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。<br>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = ‘xxx.com’;设置一致，来达到互相访问的作用。</li>
<li><strong>方式七：WebSocket</strong><br>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS<br>需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</li>
<li><strong>方式八：代理</strong><br>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题<br>DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器）</li>
</ul>
</li>
<li><h4 id="说一下JSONP实现原理？"><a href="#说一下JSONP实现原理？" class="headerlink" title="说一下JSONP实现原理？"></a>说一下JSONP实现原理？</h4><p>  jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>互联网求职——Java基础</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><strong>Java基础</strong></h3><ul>
<li><h4 id="JDK和JRE有什么区别？"><a href="#JDK和JRE有什么区别？" class="headerlink" title="JDK和JRE有什么区别？"></a>JDK和JRE有什么区别？</h4><ul>
<li>JDK:Java Development Kit 的简称，Java开发工具包，提供了Java的开发环境和运行环境。</li>
<li>JRE:Java Runtime Environment 的简称，Java运行环境，为Java提供了所需环境。<br>具体来说JDK其实包含JRE，同时还包含了编译Java源码的编译器javac，还包含了很多java程序调试和分析的工具。简单来说：如果你需要运行java程序，只需要安装JRE就可以了，如果你需要编写java程序，需要安装JDK.</li>
</ul>
</li>
<li><h4 id="与-equals-的区别是什么？"><a href="#与-equals-的区别是什么？" class="headerlink" title="== 与 equals 的区别是什么？"></a>== 与 equals 的区别是什么？</h4><ul>
<li><strong>==解读</strong></li>
</ul>
<ul>
<li>对于基本类型和应用类型==的作用效果是不同的，如下所示：<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>应用类型：比较的是引用是否相同；</li>
</ul>
</li>
</ul>
<ul>
<li><p>代码示例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x == y);//true </span><br><span class="line">System.out.println(x == z);//false</span><br><span class="line">System.out.println(x.equals(y));//true</span><br><span class="line">System.out.println(x.equals(z));//true</span><br></pre></td></tr></table></figure></li>
<li><p>代码解读：因为x和y指向的是同一个引用，所以==也是true，而new String（）方法则重写开辟了内存空间，所以==结果为false，而equals比较的一直是值，所以结果都为true</p>
</li>
<li><p><strong>equals 解读</strong></p>
</li>
</ul>
<ul>
<li>equals本质上就是==，只不过String 和 Integer 等重写了equals方法，把它变成了值比较。看下面的代码就明白了。</li>
<li>首先来看默认情况写equals比较一个有相同值得对象，代码如下：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"> String name;</span><br><span class="line"></span><br><span class="line"> public String getName() &#123;</span><br><span class="line">  return name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void setName(String name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"> public Cat(String name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  Cat c1 = new Cat(&quot;小马&quot;);</span><br><span class="line">  Cat c2 = new Cat(&quot;小马&quot;);</span><br><span class="line">  System.out.println(c1.equals(c2));</span><br><span class="line"> &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>输出结果出乎我们的意料，竟然是false？这是怎么回事，看了equals源码就知道了，源码如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals（Object obj)&#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>原来equals本质上就是==.</p>
</li>
<li><p>那么问题来了，两个相同值的String对象，为什么返回的是true？代码如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;老马&quot;);</span><br><span class="line">String s2 = new String(&quot;老马&quot;);</span><br><span class="line">System.out.println(s1.equals(s2));//true</span><br></pre></td></tr></table></figure></li>
<li><p>同样的，当我们进入String的equals方法，找到了答案，代码如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原来是String重写Object的equals方法，把引用比较该称号了值比较。</p>
</li>
<li><p>总结：==对于基本类型来说是值比较，对于引用来行来说是比较的应用；而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String、Integer等把它变成了值比较，所以一般情况下equals比较的是值是否相等。</p>
</li>
</ul>
</li>
<li><h4 id="两个对象的hashCode-相同，则equals-也一定为true，对吗？"><a href="#两个对象的hashCode-相同，则equals-也一定为true，对吗？" class="headerlink" title="两个对象的hashCode() 相同，则equals()也一定为true，对吗？"></a>两个对象的hashCode() 相同，则equals()也一定为true，对吗？</h4><ul>
<li>不对，两个对象的hashcode（）相同，equals（）不一定为true。<br>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System.out.println(String.format(&quot;str1：%d | str2：%d&quot;, str1.hashCode(), str2.hashCode());</span><br><span class="line">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure></li>
<li>执行的结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1：1179395 | str2:1179395</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li>
<li>代码解读：很显然“通话”和“重地”的hashcode（）相同，然而equals（）则为false，因为在散列表中，hashcode（）相等即两个键值对的哈希值相等，然后阿哈希值相等，并不一定得出键值对相等。</li>
</ul>
</li>
<li><h4 id="final在java中有什么作用？"><a href="#final在java中有什么作用？" class="headerlink" title="final在java中有什么作用？"></a>final在java中有什么作用？</h4><ul>
<li>final修饰的类叫最终类，该类不能被继承。</li>
<li>final修饰的方法不能被重写。</li>
<li>final修饰的变量叫常量，常量必须初始化，初始化之后值就不能改变。</li>
</ul>
</li>
<li><h4 id="String属于基础的数据类型吗？"><a href="#String属于基础的数据类型吗？" class="headerlink" title="String属于基础的数据类型吗？"></a>String属于基础的数据类型吗？</h4><ul>
<li>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</li>
</ul>
</li>
<li><h4 id="String-StringBuffer-StringBuilder的区别是什么？String为什么是不可变的？"><a href="#String-StringBuffer-StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="String, StringBuffer, StringBuilder的区别是什么？String为什么是不可变的？"></a>String, StringBuffer, StringBuilder的区别是什么？String为什么是不可变的？</h4><ul>
<li>1、String是字符串常量，StringBuffer和StringBuilder都是字符串变量。后两者的字符内容可变，而前者创建后内容不可变。</li>
<li>2、String不可变是因为在JDK中String类被声明为一个final类。</li>
<li>3、StringBuffer是线程安全的，而StringBuilder是非线程安全的。</li>
<li><strong>补充说明：</strong>线程安全会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高。如果对系统中的线程是否安全很掌握，可用StringBuffer，在线程不安全处加上关键字Synchronize。</li>
</ul>
</li>
<li><h4 id="java中的Math-round-1-5-等于多少？"><a href="#java中的Math-round-1-5-等于多少？" class="headerlink" title="java中的Math.round(-1.5)等于多少？"></a>java中的Math.round(-1.5)等于多少？</h4><ul>
<li>等于-1，以为在数轴上取值时，中间值（0.5)向右取整，负0.5是直接舍弃。</li>
</ul>
</li>
<li><h4 id="String属于基础的数据类型吗？-1"><a href="#String属于基础的数据类型吗？-1" class="headerlink" title="String属于基础的数据类型吗？"></a>String属于基础的数据类型吗？</h4><ul>
<li>String不属于基础类型，基础类型有8种：byte字节型、short短整型、int整形、long长整型、float单精度浮点型、double双精度浮点型、char字符型、Boolean布尔值，而String属于对象。</li>
</ul>
</li>
<li><h4 id="java中操作字符串的都有哪些？它们之间-有什么区别？"><a href="#java中操作字符串的都有哪些？它们之间-有什么区别？" class="headerlink" title="java中操作字符串的都有哪些？它们之间 有什么区别？"></a>java中操作字符串的都有哪些？它们之间 有什么区别？</h4><ul>
<li>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String和Stringbuffer、StringBuilder的区别在于String声明的是不可变的对象，每次操作都谁生成新的String对象，然后将指针指向新的String对象，而StringBuffer、StringBuilder可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用String。</li>
<li>StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的，但是StringBuilder的性能却高于StringBuffer，所以在单线程环境下推荐使用StringBuilder，多线程环境下推荐使用StringBuffer。 </li>
</ul>
</li>
<li><h4 id="String-str-“i”-与-String-str-new-String-“i”-一样吗？"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样吗？"></a>String str = “i” 与 String str = new String(“i”)一样吗？</h4><ul>
<li>不一样，因为内存分配方式不一样。String str = “i”的方式，java虚拟机会将其非配到常量池中；而String str = new String(“i”)则会本分配到堆内存中。 </li>
</ul>
</li>
<li><h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><ul>
<li>使用StringBuffer或者StringBuilder的reverse()方法。<br>示例代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer.append(&quot;abcdefg&quot;);</span><br><span class="line">System.out.println(stringBuffer.reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder.append(&quot;abcdefg&quot;);</span><br><span class="line">System.out.println(stringBuilder.reverse()); // gfedcba</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="String类的常用方法都有哪些？"><a href="#String类的常用方法都有哪些？" class="headerlink" title="String类的常用方法都有哪些？"></a>String类的常用方法都有哪些？</h4><ul>
<li>indexOf():返回指定字符的索引。</li>
<li>charAt():返回指定索引处的字符。</li>
<li>replace():字符串替换。</li>
<li>trim():去除字符串两端空白。</li>
<li>split():分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes():返回字符富川的byte类型数组。</li>
<li>length():返回字符串长度。</li>
<li>toLowerCase():将字符串转成小写字母。</li>
<li>toUpperCase():将字符串转成大写字母。</li>
<li>subString():截取字符串。</li>
<li>equals():字符串比较。</li>
</ul>
</li>
<li><h4 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h4><ul>
<li>不需要，抽象类不一定非要有抽象方法。示例代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">    public static void sayHi() &#123;</span><br><span class="line">        System.out.println(&quot;hi~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码，抽象类并没有抽象方法但完全可以正常运行。</li>
</ul>
</li>
<li><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
</li>
<li><h4 id="抽象类能使用final修饰吗？"><a href="#抽象类能使用final修饰吗？" class="headerlink" title="抽象类能使用final修饰吗？"></a>抽象类能使用final修饰吗？</h4><ul>
<li>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样批次就会产生矛盾，所以final不能修饰抽象类。测试如下：The class Test can be either abstract or final, not both</li>
</ul>
</li>
<li><h4 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h4><ul>
<li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有；</li>
<li>main方法：抽象类可以有main方法，并且我们能运行它；jdk1.8以下（不包含1.8）接口不能有main方法。jdk1.8及以上可以有main方法，并且可以运行。</li>
<li>实现数量：类可以实现多个接口，但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认是public修饰；抽象类中的方法可以是任意修饰符。</li>
<li>注意：接口访问修饰符只允许public、abstract、default、static和strickfp。</li>
</ul>
</li>
<li><h4 id="java中IO流分为几种"><a href="#java中IO流分为几种" class="headerlink" title="java中IO流分为几种"></a>java中IO流分为几种</h4><ul>
<li>按功能来分：输入流(input)、输出流(output)</li>
<li>按类型来分：字节流和字符流</li>
<li>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符位单位输入输出数据。</li>
</ul>
</li>
<li><h4 id="BIO、NIO、AIO有什么区别？"><a href="#BIO、NIO、AIO有什么区别？" class="headerlink" title="BIO、NIO、AIO有什么区别？"></a>BIO、NIO、AIO有什么区别？</h4><ul>
<li>BIO：Block IO 同步阻塞式IO,就是我们平常使用的传统IO,它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel(通道)通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非堵塞IO,异步IO的操作基于事件和回调机制。</li>
</ul>
</li>
<li><h4 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h4><ul>
<li>Files.exists(path, options);//检测文件路径是否存在</li>
<li>Files.createFile(path, attrs);//创建文件</li>
<li>Files.createDirectory(dir, attrs);//创建文件夹</li>
<li>Files.delete(path);//删除一个文件或目录</li>
<li>Files.copy(source, out);//复制文件</li>
<li>Files.move(source, target, options);//移动文件</li>
<li>Files.size(path);//查看文件个数</li>
<li>Files.read();//读取文件</li>
<li>Files.write(path, bytes, options);//写入文件</li>
</ul>
</li>
<li><h4 id="Java容器都有哪些？"><a href="#Java容器都有哪些？" class="headerlink" title="Java容器都有哪些？"></a>Java容器都有哪些？</h4><ul>
<li>collection <ul>
<li>List:Vector/ArrayList/LinkedList</li>
<li>Queue:PriorityQueue</li>
<li>Set:HashSet/TreeSet</li>
</ul>
</li>
<li>Map<ul>
<li>HashMap</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h4><ul>
<li>java.util.Collection是一个集合接口(集合类的一个顶级接口)。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java类库中有很多具体的实现。Collection接口的意义是为各种具体比的集合提供了最大化的同意操作方式，其直接继承接口有List和Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一些列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
</li>
<li><h4 id="抽象类必须要有抽象抽象方法吗？"><a href="#抽象类必须要有抽象抽象方法吗？" class="headerlink" title="抽象类必须要有抽象抽象方法吗？"></a>抽象类必须要有抽象抽象方法吗？</h4><ul>
<li>不需要，抽象类不一定非要有抽象方法。示例代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">    public static void sayHi() &#123;</span><br><span class="line">        System.out.println(&quot;hi~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码，抽象类并没有抽象方法但完全可以正常运行。</li>
</ul>
</li>
<li><h4 id="普通类和抽象类有哪些区别？-1"><a href="#普通类和抽象类有哪些区别？-1" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
</li>
<li><h4 id="抽象类能使用final修饰吗？-1"><a href="#抽象类能使用final修饰吗？-1" class="headerlink" title="抽象类能使用final修饰吗？"></a>抽象类能使用final修饰吗？</h4><ul>
<li>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样批次就会产生矛盾，所以final不能修饰抽象类。</li>
<li>测试如下：The class Test can be either abstract or final, not both</li>
</ul>
</li>
<li><h4 id="接口和抽象类有什么区别？-1"><a href="#接口和抽象类有什么区别？-1" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h4><ul>
<li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有；</li>
<li>main方法：抽象类可以有main方法，并且我们能运行它；jdk1.8以下（不包含1.8）接口不能有main方法。jdk1.8及以上可以有main方法，并且可以运行。</li>
<li>实现数量：类可以实现多个接口，但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认是public修饰；抽象类中的方法可以是任意修饰符。</li>
<li><strong>注意</strong>：接口访问修饰符只允许public、abstract、default、static和strickfp。</li>
</ul>
</li>
<li><h4 id="java中IO流分为几种？"><a href="#java中IO流分为几种？" class="headerlink" title="java中IO流分为几种？"></a>java中IO流分为几种？</h4><ul>
<li>按功能来分：输入流(input)、输出流(output)</li>
<li>按类型来分：字节流和字符流</li>
<li>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符位单位输入输出数据。</li>
</ul>
</li>
<li><h4 id="BIO-NIO-AIO有什么区别？"><a href="#BIO-NIO-AIO有什么区别？" class="headerlink" title="BIO/NIO/AIO有什么区别？"></a>BIO/NIO/AIO有什么区别？</h4><ul>
<li>BIO：Block IO 同步阻塞式IO,就是我们平常使用的传统IO,它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel(通道)通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非堵塞IO,异步IO的操作基于事件和回调机制。</li>
</ul>
</li>
<li><h4 id="Files的常用方法都有哪些？-1"><a href="#Files的常用方法都有哪些？-1" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h4><ul>
<li>Files.exists(path, options);//检测文件路径是否存在</li>
<li>Files.createFile(path, attrs);//创建文件</li>
<li>Files.createDirectory(dir, attrs);//创建文件夹</li>
<li>Files.delete(path);//删除一个文件或目录</li>
<li>Files.copy(source, out);//复制文件</li>
<li>Files.move(source, target, options);//移动文件</li>
<li>Files.size(path);//查看文件个数</li>
<li>Files.read();//读取文件</li>
<li>Files.write(path, bytes, options);//写入文件</li>
</ul>
</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><h4 id="Java常用的容器有哪些？"><a href="#Java常用的容器有哪些？" class="headerlink" title="Java常用的容器有哪些？"></a>Java常用的容器有哪些？</h4><ul>
<li>collection <ul>
<li>List:Vector/ArrayList/LinkedList</li>
<li>Queue:PriorityQueue</li>
<li>Set:HashSet/TreeSet</li>
</ul>
</li>
<li>Map<ul>
<li>HashMap</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="collection-和-collections-有什么区别？"><a href="#collection-和-collections-有什么区别？" class="headerlink" title="collection 和 collections 有什么区别？"></a>collection 和 collections 有什么区别？</h4><ul>
<li>java.util.Collection是一个集合接口(集合类的一个顶级接口)。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java类库中有很多具体的实现。Collection接口的意义是为各种具体比的集合提供了最大化的同意操作方式，其直接继承接口有List和Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一些列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
</li>
<li><h4 id="HashMap-和-HashTable-有什么区别？"><a href="#HashMap-和-HashTable-有什么区别？" class="headerlink" title="HashMap 和 HashTable 有什么区别？"></a>HashMap 和 HashTable 有什么区别？</h4><ul>
<li>HashMap去掉了HashTable的contains方法，但是添加上了containsKey()方法和containsValue()方法。</li>
<li>HashTable是同步的，HashMap是非同步的，效率上HashMap更快。</li>
<li>HashMap允许空键值，HashTable不允许。</li>
</ul>
</li>
<li><h4 id="HashTable-HashMap，-TreeMap的区别是什么？"><a href="#HashTable-HashMap，-TreeMap的区别是什么？" class="headerlink" title="HashTable, HashMap， TreeMap的区别是什么？"></a>HashTable, HashMap， TreeMap的区别是什么？</h4><ol>
<li>HashTable线程同步，HashMap非线程同步。</li>
<li>HashTable不允许&lt;键,值&gt;有空值，HashMap允许&lt;键,值&gt;有空值。</li>
<li>HashTable使用Enumeration，HashMap使用Iterator。</li>
<li>HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。</li>
<li>TreeMap能够把它保存的记录根据键排序，默认是按升序排序。</li>
</ol>
<p>  <strong>注意：</strong>以上三个问题所涉及的都是Java语言中的一些比较高级的数据结构，从字符串相关到容器再到哈希表和树等数据结构，因此我们在学习Java语言的时候，也需要更加深入地去对比比较类似的数据结构的使用场景以及其优缺点。</p>
</li>
<li><h4 id="如何决定使用HasMap还是TreeMap"><a href="#如何决定使用HasMap还是TreeMap" class="headerlink" title="如何决定使用HasMap还是TreeMap?"></a>如何决定使用HasMap还是TreeMap?</h4><ul>
<li>对于map的插入、删除、定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。</li>
</ul>
</li>
<li><h4 id="说一下HashMap的实现原理？"><a href="#说一下HashMap的实现原理？" class="headerlink" title="说一下HashMap的实现原理？"></a>说一下HashMap的实现原理？</h4><ul>
<li>HashMap概述：HashMap是基于哈希表的map的非同步实现。此实现提供所有的可选的映射操作，允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</li>
<li>HashMap的数据结构：在java编程语言中，最基本的结构就是两种，一个是数组，另一个是模拟指针(引用)，所有的数据结构都可以用这两个基本结构来构造。HashMap也不例外，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</li>
<li>当我们往HashMap中put元素时，首先根据key的hashCode重新计算hash值，根据这个hash值得到这个元素在数组中位置(下标)。如果该数组已经在该位置存放了元素，那么在这个位置上的元素将以链表形式存放，新加入的放在链头，最先加入的放入链尾。如果数组中该位置没有元素，就直接将该元素放到数组的该位置上。</li>
<li>需要注意的是jdk1.8对hashMap的实现进行了优化。当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)。</li>
</ul>
</li>
<li><h4 id="说一下HashSet的实现原理？"><a href="#说一下HashSet的实现原理？" class="headerlink" title="说一下HashSet的实现原理？"></a>说一下HashSet的实现原理？</h4><ul>
<li>HashSet的底层由HashMap实现。</li>
<li>HashSet的值存放在HashMap的key上。</li>
<li>HashMap的值统一为PRESENT</li>
</ul>
</li>
<li><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>
<li>最明显的区别是ArrayList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是双向循环列表，不支持随机访问。</li>
<li>使用下标访问一个元素，ArrayList的时间复杂度是O(1)而LinkedList的时间复杂度是O(n)。</li>
</ul>
</li>
<li><h4 id="Vector-ArrayList-LinkedList的区别是什么？"><a href="#Vector-ArrayList-LinkedList的区别是什么？" class="headerlink" title="Vector, ArrayList, LinkedList的区别是什么？"></a>Vector, ArrayList, LinkedList的区别是什么？</h4><ol>
<li>Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。</li>
<li>List中的元素有序、允许有重复的元素，Set中的元素无序、不允许有重复元素。</li>
<li>Vector线程同步，ArrayList、LinkedList线程不同步。</li>
<li>LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。</li>
<li>ArrayList在元素填满容器时会自动扩充容器大小的约50%，而Vector则是100%，因此ArrayList更节省空间。</li>
</ol>
</li>
<li><h4 id="如何实现数组和List之间之间的转换？"><a href="#如何实现数组和List之间之间的转换？" class="headerlink" title="如何实现数组和List之间之间的转换？"></a>如何实现数组和List之间之间的转换？</h4><ul>
<li>list转换成数组：调用ArrayList的toArray()方法。</li>
<li>数组转换为list：调用Arrays的asList()方法。</li>
</ul>
</li>
<li><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><ul>
<li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li>
<li>ArrayList运行效率比Vector更快，Vector是线程安全的。</li>
<li>ArrayList更加通用，因为我们可以使用conllections工具类轻易的获取同步列表和只读列表。</li>
</ul>
</li>
<li><h4 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h4><ul>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的。</li>
<li>Array没有提供ArrayList那么多功能，比如addAll和removeAll和iterator等。</li>
</ul>
</li>
<li><h3 id="在queue中poll-和remove-有何区别？"><a href="#在queue中poll-和remove-有何区别？" class="headerlink" title="在queue中poll()和remove()有何区别？"></a>在queue中poll()和remove()有何区别？</h3><ul>
<li>poll()和remove()都是从队列中取出一个元素，但是poll()在获取元素失败的时候回返回空，但是remove()失败的时候会抛出异常。</li>
</ul>
</li>
<li><h4 id="哪些集合是线程安全的？"><a href="#哪些集合是线程安全的？" class="headerlink" title="哪些集合是线程安全的？"></a>哪些集合是线程安全的？</h4><ul>
<li>vector：就比ArrayList多了一个同步化机制(线程安全)，因为效率太低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率(页面响应速度)是优先考虑的。</li>
<li>statck：堆栈类，先进后出。</li>
<li>hashTable：比HashMap多了一个线程安全。</li>
<li>enumeration：枚举，相当于迭代器。</li>
</ul>
</li>
<li><h4 id="迭代器Iterator是什么？"><a href="#迭代器Iterator是什么？" class="headerlink" title="迭代器Iterator是什么？"></a>迭代器Iterator是什么？</h4><ul>
<li>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常称为“轻量级”对象，因为创建它的代价小。</li>
</ul>
</li>
<li><h4 id="Iterator怎么使用？有什么特点？"><a href="#Iterator怎么使用？有什么特点？" class="headerlink" title="Iterator怎么使用？有什么特点？"></a>Iterator怎么使用？有什么特点？</h4><ul>
<li>java中Iterator功能比较简单，只能单向移动：<ul>
<li>使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()是java.lang.Iterable接口，被Conllection继承。</li>
<li>使用next()获取序列中的下一个元素。</li>
<li>使用hasNext()检查序列中是否还有元素。</li>
<li>使用remove()将迭代器新返回的元素删除。</li>
</ul>
</li>
<li>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多功能，它可以从两个方向遍历list<br>，也可以从list中插入和删除元素。</li>
</ul>
</li>
<li><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><ul>
<li>Iteroter可以遍历Set和List集合，而ListIterotor只能遍历List。</li>
<li>Iterotor对集合只能前向遍历，ListIterotor既可以前向也可以后向。</li>
<li>ListIterotor实现了Iterotor接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个或后一个元素的索引等等。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>其他面试题汇总</title>
    <url>/2019/11/22/%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>前言</p>
<p>这里我说下我的感受今年跳槽成功的难度比往年高了很多，很明显的感受就是：对于今年的java开发朋友跳槽面试，无论一面还是二面，都开始考验一个Java程序员的技术功底和基础。对源码解读和核心原理理解也是成了加分项，特别是对 Java 的一些核心基础知识点掌握的不够或者没有体系方向的朋友面试也成了一个苦恼的事情。</p>
<p>今天在这分享目前国内公司Java面试常问的问题包括JVM、常用的算法和数据结构，redis缓存，分布式，Spring，Kafka，Nginx，微服务等。正所谓知己知彼，只有体系知识巩固，面对不断更新的技术才能快速掌握，同时在面试、工作中也更能脱颖而出！<br>在来说下阿里员工的等级划分吧！当前，据统计阿里巴巴有在职员工3W多名，根据不同岗位和职责划分为十个级别。</p>
<p>一到三分为低端岗位，四等级的为初级专员，五等级的是高级工程师，一年有15到25万的工资。</p>
<p>六等级的为资深工程师，一年有20到35万工资。七等级的是技术专家，年薪在30到50万之间。八等级为高级专家，年薪在45万到80万之间。九等级的是资深专家，一年工薪有80到100万。</p>
<p>最高等级的是研究员，年薪百万之上。除此之外，七级别以上的可以拿到公司股票，折算下来比工资还高。</p>
<p>阿里150道高频常问Java体系面试问题</p>
<p>Java集合22题</p>
<p>ArrayList 和 Vector 的区别。<br>说说 ArrayList,Vector, LinkedList 的存储性能和特性。<br>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？<br>hashmap 的数据结构。<br>HashMap 的工作原理是什么?<br>Hashmap 什么时候进行扩容呢？<br>List、Map、Set 三个接口，存取元素时，各有什么特点？<br>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?<br>两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?<br>heap 和 stack 有什么区别。<br>Java 集合类框架的基本接口有哪些？<br>HashSet 和 TreeSet 有什么区别？<br>HashSet 的底层实现是什么?<br>LinkedHashMap 的实现原理?<br>为什么集合类没有实现 Cloneable 和 Serializable 接口？<br>什么是迭代器 (Iterator)？<br>Iterator 和 ListIterator 的区别是什么？<br>数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？<br>Java 集合类框架的最佳实践有哪些？<br>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？<br>Comparable 和 Comparator 接口是干什么的？列出它们的区别<br>Collection 和 Collections 的区别。<br>JVM与调优21题</p>
<p>Java 类加载过程？<br>描述一下 JVM 加载 Class 文件的原理机制?<br>Java 内存分配。<br>GC 是什么? 为什么要有 GC？<br>简述 Java 垃圾回收机制<br>如何判断一个对象是否存活？（或者 GC 对象的判定方法）<br>垃圾回收的优点和原理。并考虑 2 种回收机制<br>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？<br>Java 中会存在内存泄漏吗，请简单描述<br>深拷贝和浅拷贝。<br>System.gc() 和 Runtime.gc() 会做什么事情？<br>finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？<br>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？<br>什么是分布式垃圾回收（DGC）？它是如何工作的？<br>串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？<br>在 Java 中，对象什么时候可以被垃圾回收？<br>简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。<br>JVM 的永久代中会发生垃圾回收么？<br>Java 中垃圾收集的方法有哪些？<br>什么是类加载器，类加载器有哪些？<br>类加载器双亲委派模型机制？<br>并发编程28题</p>
<p>Synchronized 用过吗，其原理是什么？<br>你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？<br>什么是可重入性，为什么说 Synchronized 是可重入锁？<br>JVM 对 Java 的原生锁做了哪些优化？48<br>为什么说 Synchronized 是非公平锁？49<br>什么是锁消除和锁粗化？49<br>为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？<br>乐观锁一定就是好的吗？<br>跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？<br>那么请谈谈 AQS 框架是怎么回事儿？<br>请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。<br>ReentrantLock 是如何实现可重入性的？<br>除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？<br>请谈谈 ReadWriteLock 和 StampedLock。<br>如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。<br>CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？<br>Java 线程池相关问题<br>Java 中的线程池是如何实现的？<br>创建线程池的几个核心构造参数？<br>线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？<br>既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同<br>如何在 Java 线程池中提交线程？<br>什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？<br>请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？<br>既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？<br>请对比下 volatile 对比 Synchronized 的异同。<br>请谈谈 ThreadLocal 是怎么解决并发安全的？<br>很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？<br>spring面试专题</p>
<p>1、什么是 Spring 框架？Spring 框架有哪些主要模块？<br>2、使用 Spring 框架能带来哪些好处？<br>3、什么是控制反转(IOC)？什么是依赖注入？<br>4、请解释下 Spring 框架中的 IoC？<br>5、BeanFactory 和 ApplicationContext 有什么区别？<br>6、Spring 有几种配置方式？<br>7、如何用基于 XML 配置的方式配置 Spring？<br>8、如何用基于 Java 配置的方式配置 Spring？<br>9、怎样用注解的方式配置 Spring？<br>10、请解释 Spring Bean 的生命周期？<br>11、Spring Bean 的作用域之间有什么区别？<br>12、什么是 Spring inner beans？<br>13、Spring 框架中的单例 Beans 是线程安全的么？<br>14、请举例说明如何在 Spring 中注入一个 Java Collection？<br>15、如何向 Spring Bean 中注入一个 Java.util.Properties？<br>16、请解释 Spring Bean 的自动装配？<br>17、请解释自动装配模式的区别？<br>18、如何开启基于注解的自动装配？<br>19、请举例解释@Required 注解？<br>20、请举例解释@Autowired 注解？<br>21、请举例说明@Qualifier 注解？<br>22、构造方法注入和设值注入有什么区别？<br>23、Spring 框架中有哪些不同类型的事件？<br>24、FileSystemResource 和 ClassPathResource 有何区别？<br>25、Spring 框架中都用到了哪些设计模式？</p>
<p>答案详解</p>
<p>设计模式</p>
<p>1.请列举出在 JDK 中几个常用的设计模式？<br>2.什么是设计模式？你是否在你的代码里面使用过任何设计模式？<br>3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式<br>4.在 Java 中，什么叫观察者设计模式（observer design pattern）？<br>5.使用工厂模式最主要的好处是什么？在哪里使用？<br>6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类<br>层次？<br>7.在 Java 中，为什么不允许从静态方法中访问非静态变量？<br>8.设计一个 ATM 机，请说出你的设计思路？<br>9.在 Java 中，什么时候用重载，什么时候用重写？<br>10.举例说明什么情况下会更倾向于使用抽象类而不是接口</p>
<p>答案详解</p>
<p>springboot面试专题</p>
<p>什么是 Spring Boot？<br>Spring Boot 有哪些优点？<br>什么是 JavaConfig？<br>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？<br>Spring Boot 中的监视器是什么？<br>如何在 Spring Boot 中禁用 Actuator 端点安全性？<br>如何在自定义端口上运行 Spring Boot 应用程序？<br>什么是 YAML？<br>如何实现 Spring Boot 应用程序的安全性？<br>如何集成 Spring Boot 和 ActiveMQ？<br>如何使用 Spring Boot 实现分页和排序？<br>什么是 Swagger？你用 Spring Boot 实现了它吗？<br>什么是 Spring Profiles？<br>什么是 Spring Batch？<br>什么是 FreeMarker 模板？<br>如何使用 Spring Boot 实现异常处理？<br>您使用了哪些 starter maven 依赖项？<br>什么是 CSRF 攻击？<br>什么是 WebSockets？<br>什么是 AOP？<br>什么是 Apache Kafka？<br>我们如何监视所有 Spring Boot 微服务？</p>
<p>面试答案详解</p>
<p>Nginx18题</p>
<p>1、请解释一下什么是 Nginx?</p>
<p>2、请列举 Nginx 的一些特性。</p>
<p>3、请列举 Nginx 和 Apache 之间的不同点</p>
<p>4、请解释 Nginx 如何处理 HTTP 请求</p>
<p>5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</p>
<p>6、 使用“反向代理服务器”的优点是什么?</p>
<p>7、请列举 Nginx 服务器的最佳用途。</p>
<p>8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</p>
<p>9、请解释你如何通过不同于 80 的端口开启 Nginx?</p>
<p>10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</p>
<p>11、在 Nginx 中，解释如何在 URL 中保留双斜线?</p>
<p>12、请解释 ngx_http_upstream_module 的作用是什么?</p>
<p>13、请解释什么是 C10K 问题?</p>
<p>14、请陈述 stub_status 和 sub_filter 指令的作用是什么?</p>
<p>15、解释 Nginx 是否支持将请求压缩到上游?</p>
<p>16、解释如何在 Nginx 中获得当前的时间?</p>
<p>17、用 Nginx 服务器解释-s 的目的是什么?</p>
<p>18、解释如何在 Nginx 服务器上添加模块?</p>
<p>面试答案详解</p>
<p>Kafka17题</p>
<p>1.Kafka 的设计时什么样的呢？</p>
<p>2.数据传输的事物定义有哪三种？</p>
<p>3.Kafka 判断一个节点是否还活着有那两个条件？</p>
<p>4.producer 是否直接将数据发送到 broker 的 leader(主节点)？</p>
<p>5、Kafa consumer 是否可以消费指定分区消息？</p>
<p>6、Kafka 消息是采用 Pull 模式，还是 Push 模式？</p>
<p>7.Kafka 存储在硬盘上的消息格式是什么？</p>
<p>8.Kafka 高效文件存储设计特点：</p>
<p>9.Kafka 与传统消息系统之间有三个关键区别</p>
<p>10.Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中</p>
<p>11.Kafka 新建的分区会在哪个目录下创建</p>
<p>12.partition 的数据如何保存到硬盘</p>
<p>13.kafka 的 ack 机制</p>
<p>14.Kafka 的消费者如何消费数据</p>
<p>15.消费者负载均衡策略</p>
<p>16.数据有序</p>
<p>17.kafaka 生产数据时数据的分组策略</p>
<p>面试答案详解</p>
<p>Redis</p>
<p>什么是redis?<br>Reids的特点<br>Redis支持的数据类型<br>Redis是单进程单线程的<br>虚拟内存<br>Redis锁<br>读写分离模型<br>数据分片模型<br>Redis的回收策略<br>使用Redis有哪些好处？<br>redis相比memcached有哪些优势？4<br>redis常见性能问题和解决方案<br>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据245<br>Memcache与Redis的区别都有哪些？<br>Redis 常见的性能问题都有哪些？如何解决？<br>Redis 最适合的场景</p>
]]></content>
  </entry>
  <entry>
    <title>HR面试问答</title>
    <url>/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E4%B9%8BHR%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
    <content><![CDATA[<h2 id="HR面试问答篇"><a href="#HR面试问答篇" class="headerlink" title="HR面试问答篇"></a>HR面试问答篇</h2><h3 id="1-问：请你先自我介绍一下？【条理清晰-一气呵成】"><a href="#1-问：请你先自我介绍一下？【条理清晰-一气呵成】" class="headerlink" title="1. 问：请你先自我介绍一下？【条理清晰+一气呵成】"></a>1. 问：请你先自我介绍一下？<strong>【条理清晰+一气呵成】</strong></h3><ul>
<li><p><strong>解析：</strong>面试官想要通过这个问题了解你能否胜任工作，不要简单读简历，而是要在短时间内介绍清楚自己的特点与优势，利用STAR法则表现自己【S：Situation，指的是项目背景T：Task，项目任务A：Action，你自己承担的工作R：Result，工作结果】。</p>
</li>
<li><p><strong>xiexj：</strong><br>  我在上家公司做xx方面的工作，曾经处理过xx问题，我用xx方式进行了优化，达到了xx好的效果。经常使用xx语言，喜欢研究xx技术，关注xx领域（与面试公司匹配）其他的工作还有xx。另外xx方面的工作（与应聘岗位匹配）我也喜欢，平时也看阿里、腾讯、美团等大厂的技术文章，去github学习。</p>
<ol>
<li>业务需求可以一笔带过，用寥寥几句话介绍项目的背景，大致做了什么，工期和人数即可，别讲太多，因为面试官不关心。下面给出一个说辞的案例。<br>我上个项目是做电信系统的计费软件，客户是xxx，工期是xxx个月，有5个人一起做，我在里面做的是开发。</li>
<li>结合项目实际需求，介绍项目用到的技术，比如在上述职位描述里，要求有spring mvc，消息中间件，数据库等需求，下面同样给出各说辞的案例。<br>在这个项目里，我们用到了Spring MVC（或Spring Boot或Spring Cloud）框架，数据库是用Oracle，ORM组件是用Mytabis，在项目里，我们在是通过消息queue来发送计费成功的消息，消息中间件我们使用Kafka，为了降低数据库访问次数，我们会把客户信息放在redis缓存中。此外，我们在网关层接入了nginx做负载均衡。<br>大家能看到，在上述说辞里，我们结合了案例，说出了招聘方需要的技术点，不过请注意，这里仅仅是介绍项目，结合功能点说出技术即可，别过多展开，因为一旦过度展开，就会让面试官感觉你思路不清晰，或者凭借准备有恃无恐。</li>
<li>再结合项目，说些招聘方需要的非技术的要求。<br>在这个项目里，我们用到了xx设计模式，而且，我们会定期review代码，以求保证代码的质量，而且，当项目工期比较紧的时候，我还会客串配置管理的角色。在这个项目里，我一有问题，马上会和经理或测试或其它组的人沟通。</li>
<li>如果有，说下你在项目里的亮点，比如用到了一些比较好的技术。<br>这个项目对数据库性能和内存性能要求比较高，所以我用到了Oracle调优技术和JVM内存优化技术，此外，我们还用到了大数据分析的工具对计费模式做了优化。<br>大家看到,上述说辞不复杂，准备好以后，说起来估计也就2，3分钟 但就通过上述说辞，亮出了你的基本信息，而且能给面试官留下思路清晰，技术匹配的印象。</li>
</ol>
</li>
</ul>
<h3 id="2-问：你的优点是什么？【个人特征-岗位需求】"><a href="#2-问：你的优点是什么？【个人特征-岗位需求】" class="headerlink" title="2. 问：你的优点是什么？【个人特征+岗位需求】"></a>2. 问：你的优点是什么？<strong>【个人特征+岗位需求】</strong></h3><ul>
<li><strong>解析：</strong>优点可以解析沉着冷静. 条理清晰. 乐观开朗. 乐于助人. 细心认真等，可以结合你求职的岗位需求，真诚回应。</li>
<li><strong>xiexj：</strong>自定义标签：<br>沟通能力：跨部门（产品. 技术. 测试）沟通，明确需求细节<br>抗压能力：两段创业公司经历，熟悉996，最长一段工作时间是连续3个月高强度工作<br>适应能力：从项目最初的89个bug，到每期迭代最多不超过3个bug，一般情况是1-2个。<br>分析能力：运营后端整体jsp页面优化展开，全权一人负责。<br>观察能力：<br>时间管理能力：</li>
</ul>
<h3 id="3-问：你最大的缺点是什么？【无伤大雅-承诺克服】"><a href="#3-问：你最大的缺点是什么？【无伤大雅-承诺克服】" class="headerlink" title="3. 问：你最大的缺点是什么？【无伤大雅+承诺克服】"></a>3. 问：你最大的缺点是什么？<strong>【无伤大雅+承诺克服】</strong></h3><ul>
<li><strong>解析：</strong>这类问题的目的是看你的性格是否合适公司文化。首先要诚实，其次要确保你的答案不是“一句话毁掉一份工作”。如你去面试销售，就不要说“我特别不会和人打交道”，这是销售岗位至关重要的品质。最后，一定要给出你会怎样克服这个毛病的具体行动。</li>
<li><strong>xiexj：</strong> 从专业技能角度来讲，目前最大的短板就是各项开发技能尚未精通。从沟通角度来讲，英语也是目前的短板。<br>当然，您也了解了，我最近参加了ARTS打卡计划，其主要目的就是更高效的学习，以及更好提升自己英文阅读能力。平时也有从英语流利说中学习口语。</li>
</ul>
<h3 id="4-问：最能概括你的三个词是什么？【关键词-具体例子】"><a href="#4-问：最能概括你的三个词是什么？【关键词-具体例子】" class="headerlink" title="4. 问：最能概括你的三个词是什么？【关键词+具体例子】"></a>4. 问：最能概括你的三个词是什么？<strong>【关键词+具体例子】</strong></h3><ul>
<li><strong>解析：</strong>面试官想要考察的是你是否适合这个岗位。如果你面试的岗位是行政岗位，那么你可以解析“我工作细心，适应能力强，具有强大的责任心”，并且结合具体的例子向面试官解释。</li>
<li><strong>xiexj：</strong>参考2</li>
</ul>
<h3 id="5-问：除了工作，平时还喜欢干什么？【岗位相关-团队协作】"><a href="#5-问：除了工作，平时还喜欢干什么？【岗位相关-团队协作】" class="headerlink" title="5. 问：除了工作，平时还喜欢干什么？【岗位相关+团队协作】"></a>5. 问：除了工作，平时还喜欢干什么？<strong>【岗位相关+团队协作】</strong></h3><ul>
<li><strong>解析：</strong>这道题考察的是你的生活态度和性格特征，从而判断是否符合公司调性。如果面试销售岗位，被问到工作以外喜欢干什么，你回答喜欢宅着看剧. 打游戏，面试官可能会觉得你的性格并不适合销售。此外，大多数工作都非单个人独立能胜任，因此可以回答旅游. 爬山. 篮球等，可以体现团队合作精神。</li>
<li><strong>xiexj：</strong>学习能力：参考自我描述；团队能力：打篮球，崇尚团队至上的理念；耐力：健身。</li>
</ul>
<h3 id="6-问：你为什么会选择我们公司？【做好功课-企业文化】"><a href="#6-问：你为什么会选择我们公司？【做好功课-企业文化】" class="headerlink" title="6. 问：你为什么会选择我们公司？【做好功课+企业文化】"></a>6. 问：你为什么会选择我们公司？<strong>【做好功课+企业文化】</strong></h3><ul>
<li><strong>解析：</strong>面试前，应该对面试的企业有所了解，事先做好功课。可以上公司网站了解该公司的企业文化. 有吸引力的项目，也可以找公司前辈聊天，准备好三点有说服力的理由。如“贵公司的导师制度非常注重新员工的职业发展，对我很有吸引力。”</li>
<li><strong>xiexj：</strong></li>
</ul>
<h3 id="7-问：你对薪资的要求是多少？【出于热爱-不会亏待】"><a href="#7-问：你对薪资的要求是多少？【出于热爱-不会亏待】" class="headerlink" title="7. 问：你对薪资的要求是多少？【出于热爱+不会亏待】"></a>7. 问：你对薪资的要求是多少？<strong>【出于热爱+不会亏待】</strong></h3><ul>
<li><strong>解析：</strong>首先表达对工作的热爱，表明你是因为喜欢这份工作，同时也喜欢这个单位，所以才来应聘。其次，你初入职场，所以在薪资方面的期望值不会太高。第三，你相信，公司在确认了你的工作能力后，一定会给你一个恰当的待遇。</li>
<li>xiexj： 我在招聘网站，看到这个岗位的薪资是在10-15k之间，我目前工作的薪资是14.4+1K,我希望在此基础上，有20%左右的的涨幅。应该是在贵公司的预算范围之内。当然，如果有其他如学习机会、晋升机会等，我也会中和考虑。</li>
</ul>
<h3 id="8-问：你能否接受加班？【愿意接受-提高效率】"><a href="#8-问：你能否接受加班？【愿意接受-提高效率】" class="headerlink" title="8. 问：你能否接受加班？【愿意接受+提高效率】"></a>8. 问：你能否接受加班？<strong>【愿意接受+提高效率】</strong></h3><ul>
<li><strong>解析：</strong>你可以解析“我愿意接受挑战。在自己责任范围内的工作，不能算加班”。但要强调，自己一定会避免因效率低造成的加班，努力提高工作效率。</li>
<li><strong>xiexj：</strong>原意接受挑战。在自己的责任方位内的工作，不能算加班。其次也会合理的安排工作计划，避免因效率低造成加班。</li>
</ul>
<h3 id="9-问：为什么选择你，而不是别人？【专注自我-创造互动】"><a href="#9-问：为什么选择你，而不是别人？【专注自我-创造互动】" class="headerlink" title="9. 问：为什么选择你，而不是别人？【专注自我+创造互动】"></a>9. 问：为什么选择你，而不是别人？<strong>【专注自我+创造互动】</strong></h3><ul>
<li><strong>解析：</strong>可以从岗位需求出发分析自己的长处，说明自己很适合这个岗位；也可以根据情况反问面试官：“您认为做好这份工作，候选人应该具备怎么样的条件？”，进而于面试官进行互动，留下深刻印象。</li>
<li><strong>xiexj：</strong>（利用在提问的艺术中学到的知识，以提问的方式互动话题）<br>您认为做好这份工作，候选人需要具备怎么样的条件呢？</li>
</ul>
<h3 id="10-问：你近五年的职业规划是怎样的？【自我认知-组织承诺】"><a href="#10-问：你近五年的职业规划是怎样的？【自我认知-组织承诺】" class="headerlink" title="10. 问：你近五年的职业规划是怎样的？【自我认知+组织承诺】"></a>10. 问：你近五年的职业规划是怎样的？<strong>【自我认知+组织承诺】</strong></h3><ul>
<li><strong>解析：</strong>在自我认知清楚的前提下，结合公司的人才培养机制，对自己有一个清晰的规划。尽量具体到每一年，这样也是给公司做出承诺：不会轻易跳槽。</li>
<li><strong>xiexj：</strong> 5年规划：第一步，先成为一名优秀的高级开发人员；第二步，成为这个领域的技术专家；第三步：成长为一名合格的初级架构师，并不断的想高级乃至更高级别的架构师迈进。</li>
</ul>
<h3 id="11-问：在完成某项工作时，你觉得领导的指示不对，你会怎么做？【尊重服从-真诚表达】"><a href="#11-问：在完成某项工作时，你觉得领导的指示不对，你会怎么做？【尊重服从-真诚表达】" class="headerlink" title="11. 问：在完成某项工作时，你觉得领导的指示不对，你会怎么做？【尊重服从+真诚表达】"></a>11. 问：在完成某项工作时，你觉得领导的指示不对，你会怎么做？<strong>【尊重服从+真诚表达】</strong></h3><ul>
<li><strong>解析：</strong>作为员工，原则上要尊重和服从领导的工作安排，但私下可以用请教的口吻表达自己的想法，和领导进行探讨。若领导没有采纳意见，你会认真完成工作；若领导的要求违背原则，你也会提出反对意见。</li>
<li><strong>xiexj：</strong>同上述解析。</li>
</ul>
<h3 id="12-问：你希望与什么样的上级共事？【避重就轻-要求自我】"><a href="#12-问：你希望与什么样的上级共事？【避重就轻-要求自我】" class="headerlink" title="12. 问：你希望与什么样的上级共事？【避重就轻+要求自我】"></a>12. 问：你希望与什么样的上级共事？<strong>【避重就轻+要求自我】</strong></h3><ul>
<li><strong>解析：</strong> 避免对上级提出具体要求，而是从自己入手。如“作为职场新人，理应尽快熟悉环境. 适应工作，而不应该对环境提要求。只要能发挥能力，做好工作即可。”</li>
<li><strong>xiexj：</strong>首先作为一名刚入职的员工，首要应该尽快熟悉环境，适应工作；其次，希望与什么样的领导共事，我可以这样去分析，领导之所以成为领导必然有其过人之处，作为员工的我，首先也应该主动去熟悉领导的行事风格，然后才能拥有更好的. 更高效的执行能力。<br>也可以打哈哈的说，希望领导是如马云一般地人物，当然是开玩笑的口吻，并视具体面试人而定。</li>
</ul>
]]></content>
      <categories>
        <category>互联网求职</category>
      </categories>
  </entry>
  <entry>
    <title>项目管理利器</title>
    <url>/2019/11/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8MAVEN/</url>
    <content><![CDATA[<h1 id="项目管理利器-maven（windows7-jdk1-8）"><a href="#项目管理利器-maven（windows7-jdk1-8）" class="headerlink" title="项目管理利器 maven（windows7 jdk1.8）"></a>项目管理利器 maven（windows7 jdk1.8）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Maven(Apache)是一个软件项目管理和理解工具。基于项目对象模型（POM）的概念，Maven可以从中央信息管理项目的构建，报告和文档。<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2></li>
<li>bin ：主要包含了mvn运行脚本</li>
<li>boot ：类加载起的框架</li>
<li>conf：配置文件 settting.xml（非常重要的文件）</li>
<li>lib：maven类库</li>
<li>LICENSE：maven使用的软件许可证</li>
<li>NOTICE：maven包含的第三方软件</li>
<li>README.txt：Maven的简要介绍，包括安装需求及如何安装的简要指令等。<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2></li>
<li>编辑系统变量 MAVNE_HOME : D:\software\apache-maven-3.3.9</li>
<li>编辑系统变量 Path ：%MAVEN_HOME%\bin;</li>
<li>进入dos命令界面：输入 mvn -v,如果显示maven版本及jdk以及系统相关的信息—&gt;成功，否则—&gt;失败，检查环境变量是否配置正确。<h2 id="maven项目目录结构"><a href="#maven项目目录结构" class="headerlink" title="maven项目目录结构"></a>maven项目目录结构</h2></li>
<li>src<ul>
<li>main<ul>
<li>java</li>
<li>resources</li>
<li>filters</li>
</ul>
</li>
<li>test<ul>
<li>java</li>
<li>resources</li>
<li>filters</li>
</ul>
</li>
<li>it</li>
<li>assembly</li>
<li>site</li>
</ul>
</li>
</ul>
<ul>
<li>pom.xml </li>
<li>LICENSE.txt</li>
<li>NOTICE.txt</li>
<li>README.txt</li>
</ul>
<h2 id="Maven常用构建命令"><a href="#Maven常用构建命令" class="headerlink" title="Maven常用构建命令"></a>Maven常用构建命令</h2><ul>
<li>查看版本信息: mvn -v</li>
<li>编译项目：mvn compile</li>
<li>测试项目：mvn test</li>
<li>项目打包：mvn package</li>
<li>删除target：mvn clean</li>
<li>安装jar包到本地仓库中：mvn install </li>
<li>创建目录：<ul>
<li>选择性创建目录： mvn archetype:generate</li>
<li>一次性创建目录： mvn archetype：generate -DgroupId=组织名 -DartifactId=项目名 -Dversion=版本号 -Dpackage=包名<h2 id="Maven坐标和仓库"><a href="#Maven坐标和仓库" class="headerlink" title="Maven坐标和仓库"></a>Maven坐标和仓库</h2></li>
</ul>
</li>
<li>坐标：构件</li>
<li>仓库：<ul>
<li>本地仓库</li>
<li>本地私服</li>
<li>中央仓库(maven安装目录 -&gt; lib -&gt; maven-model-builder-3.3.9.jar - &gt;pom.xml可以找到中央仓库)</li>
<li>镜像仓库</li>
</ul>
</li>
<li>更改仓库位置<ul>
<li>本地仓库修改： 修改setting.xml，加入或修改原有localRepository，如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;localRepository&gt;D:/software/apache-maven-3.3.9/repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure></li>
<li>镜像仓库修改： 修改setting.xml，加入或修改原有mirror，如：修改为阿里云镜像仓库  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        &lt;mirror&gt;  </span><br><span class="line">        &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">        &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">        &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;  </span><br><span class="line">        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;mirror&gt;  </span><br><span class="line">        ```   </span><br><span class="line">## Maven生命周期</span><br><span class="line">+ 项目的构建过程 : 清理,编译,测试,打包,集成测试,验证,部署</span><br><span class="line">+ Maven生命周期</span><br><span class="line">    - clean     清理项目</span><br><span class="line">        * pre-clean 执行清理前的工作</span><br><span class="line">        * clean 清理上一次构建生成的文件</span><br><span class="line">        * post-clean 执行清理后的文件</span><br><span class="line">    - default   构建项目（核心）</span><br><span class="line">        * compile、test、package、install</span><br><span class="line">    - site      生成项目站点</span><br><span class="line">        * pre-site 在生成站点前要完成的工作</span><br><span class="line">        * site 生成项目的站点文档</span><br><span class="line">        * post-site 在生成项目站点后要完成的工作</span><br><span class="line">        * site-deploy 发布生成的站点到服务器上</span><br><span class="line">## Maven pom解析</span><br><span class="line">+ [详细](https://maven.apache.org/pom.html)</span><br><span class="line">+ 常用</span><br><span class="line">    + 基础知识</span><br></pre></td></tr></table></figure>
<!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.xie.project-group，maven会将该项目打成的jar包放本地路径：/com/xie/project-group -->
<groupId> … &lt;/ groupId&gt;<!-- 项目的唯一ID，一个groupId下面可能多个项目，需要artifactId来区分的 -->
<artifactId> … &lt;/ artifactId&gt;<!-- 版本号 -->
&lt;!– 第一个0表示大版本号，第二个0表示分支版本号，第三个0表示小版本号<br>  SNAPSHOT 快照<br>  ALPHA 内部测试<br>  BETA 公测<br>  RELEASE 稳定<br>  GA 正式发布</li>
<li>-&gt;<br><version> … &lt;/ version&gt;<!--默认jar，也可以是pom，jar，maven-plugin，ejb，war，ear，rar-->
<packaging> … &lt;/ packaging&gt;<!--依赖项-->
<dependencies> … &lt;/ dependencies&gt;<br><parent> … &lt;/ parent&gt;<br><dependencyManagement> … &lt;/ dependencyManagement&gt;<br><modules> … &lt;/ modules&gt;<br><properties> … &lt;/ properties&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 构建设置</span><br></pre></td></tr></table></figure>
<build> … &lt;/ build&gt;<br><reporting> … &lt;/ reporting&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 更多项目信息</span><br></pre></td></tr></table></figure>
<!--项目名-->
<name> … &lt;/ name&gt;<!--项目描述-->
<description> … &lt;/ description&gt;<!--项目地址-->
<url> … &lt;/ url&gt;<br><inceptionYear> … &lt;/ inceptionYear&gt;<!--许可证信息-->
<licenses> … &lt;/ licenses&gt;<!--组织信息-->
<organization> … &lt;/ organization&gt;<!--开发人员信息-->
<developers> … &lt;/ developers&gt;<br><contributors> … &lt;/ contributors&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 环境设置</span><br></pre></td></tr></table></figure>
<issueManagement> … &lt;/ issueManagement&gt;<br><ciManagement> … &lt;/ ciManagement&gt;<br><mailingLists> … &lt;/ mailingLists&gt;<br><scm> … &lt;/ scm&gt;<br><prerequisites> … &lt;/ prerequisites<br><repositories> … &lt;/ repositories&gt;<br><pluginRepositories> … &lt;/ pluginRepositories&gt;<br><distributionManagement> … &lt;/ distributionManagement&gt;<br><profiles> … &lt;/ profiles&gt;<pre><code></code></pre></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础学习篇</category>
      </categories>
  </entry>
  <entry>
    <title>与MySQL零距离接触</title>
    <url>/2019/11/13/%E4%B8%8EMySQL%E9%9B%B6%E8%B7%9D%E7%A6%BB%E6%8E%A5%E8%A7%A6-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>mysql是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS(Relation Database Management System,关系数据库管理系统)应用软件之一。</p>
<h1 id="2-MySQL的安装与配置"><a href="#2-MySQL的安装与配置" class="headerlink" title="2.MySQL的安装与配置"></a>2.MySQL的安装与配置</h1><ul>
<li>MySQL安装方式(Windows)<ul>
<li>MSI安装</li>
</ul>
<ol>
<li>双击mysql-5.7.17.msi<ul>
<li>Developer Default(安装所有 MySQL 数据库需要的产品)</li>
<li>Server only (仅仅使用 MySQL 数据库的服务器)</li>
<li>Client only (仅仅使用 MySQL 数据库的客户端)</li>
<li>Full (安装所有包含 MySQL 数据库的产品)</li>
<li>Custom (手动选择需要安装的 MySQL 数据库的产品) </li>
</ul>
</li>
<li>选择server only</li>
<li>当MySQL数据库升级成功后，点击next</li>
<li>一路点击next，直到Type and Networking页（这里我选择默认配置，也可以根据自身需求自定义）<ul>
<li>Config type（配置服务器类型）</li>
<li>TCP/IP（选择TCP/IP协议）</li>
<li>Port Number（选择端口号：默认3306）</li>
</ul>
</li>
<li>设置账号和角色<ul>
<li>只需要设置root账号的密码</li>
<li>必须记住，登录MySQL数据库是需要验证</li>
<li>密码至少4位</li>
</ul>
</li>
<li>一路next直至finish收工</li>
<li>配置环境变量</li>
</ol>
<ul>
<li>ZIP安装</li>
</ul>
</li>
<li>官网下载地址<ul>
<li><a href="https://downloads.mysql.com/archives/installer/" target="_blank" rel="noopener">下载</a></li>
</ul>
</li>
</ul>
<h1 id="3-MySQL目录结构"><a href="#3-MySQL目录结构" class="headerlink" title="3. MySQL目录结构"></a>3. MySQL目录结构</h1><ul>
<li>bin目录（存储可执行文件）</li>
<li>docs目录（文档）</li>
<li>include目录（存储包含的头文件）</li>
<li>lib目录（存储库文件）</li>
<li>share目录（错误消息和字符集文件）</li>
</ul>
<h1 id="4-启动-关闭MySQL服务"><a href="#4-启动-关闭MySQL服务" class="headerlink" title="4.启动/关闭MySQL服务"></a>4.启动/关闭MySQL服务</h1><ul>
<li>Windows图形化界面启动/关闭MySQL服务<ul>
<li>win+R 打开运行窗口</li>
<li>输入services.msc（服务界面）</li>
<li>找到MySQL服务，进行启动/关闭操作</li>
</ul>
</li>
<li>dos命令启动/关闭MySQL服务<ul>
<li>win+R 打开运行窗口，输入cmd，进入dos命令行界面</li>
<li>输入MySQL命令：<ul>
<li>启动命令：net start mysql</li>
<li>关闭命令：net stop mysql</li>
<li><strong>注意：</strong> 以上命令中“mysql”对应的是mysql服务名称，如我安装的是MySQL5.7.17(安装默认服务名称)，那么我的命令就是net start/stop mysql57</li>
<li>net start/stop 命令对于Windows所有的服务都可以实现启动与关闭操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="5-MySQL的登录与退出"><a href="#5-MySQL的登录与退出" class="headerlink" title="5.MySQL的登录与退出"></a>5.MySQL的登录与退出</h1><ul>
<li><p>MySQL登录：mysql + 参数<br>  <strong>mysql -h127.0.0.1 -P3306 -uroot -proot</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>参数</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">-D , –database = name</td>
<td align="left">打开指定数据库</td>
</tr>
<tr>
<td align="left"><strong>-P</strong>,-port = #</td>
<td align="left">端口号</td>
</tr>
<tr>
<td align="left">-p , –password [=name]</td>
<td align="left">密码</td>
</tr>
<tr>
<td align="left">-u ,–user = name</td>
<td align="left">用户名/登录名</td>
</tr>
<tr>
<td align="left">–delimiter = name</td>
<td align="left">指定分隔符</td>
</tr>
<tr>
<td align="left">-h , –host = name</td>
<td align="left">服务器名称</td>
</tr>
<tr>
<td align="left">–prompt = name</td>
<td align="left">设置提示符</td>
</tr>
<tr>
<td align="left">-V , –version</td>
<td align="left">输出版本信息并且退出</td>
</tr>
<tr>
<td align="left"><strong>注意</strong> 端口号与密码大小写，端口号大写 <strong>P</strong> ,密码小写<strong>p</strong>。</td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
<li><p>MySQL退出（进入到MySQL命令行操作界面）</p>
<ul>
<li>mysql &gt; exit;</li>
<li>mysql &gt; quit;</li>
<li>mysql &gt; \q;</li>
</ul>
</li>
</ul>
<h1 id="6-MySQL提示符"><a href="#6-MySQL提示符" class="headerlink" title="6.MySQL提示符"></a>6.MySQL提示符</h1><ul>
<li><p>连接客户端时通过prompt修改</p>
<ul>
<li><strong>mysql -uroot -proot –prompt</strong> 参数（可自定义）</li>
</ul>
</li>
<li><p>连接上客户端之后通过prompt修改</p>
<ul>
<li><strong>prompt</strong> 参数（可自定义）</li>
</ul>
</li>
<li><p>提示符</p>
<table>
<thead>
<tr>
<th align="left"><strong>参数</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">\D</td>
<td align="left">完整日期</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">当前数据库</td>
</tr>
<tr>
<td align="left">\h</td>
<td align="left">服务器名称</td>
</tr>
<tr>
<td align="left">\u</td>
<td align="left">当前用户</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="7-MySQL语句规范"><a href="#7-MySQL语句规范" class="headerlink" title="7.MySQL语句规范"></a>7.MySQL语句规范</h1><ul>
<li>关键字与函数名称全部大写</li>
<li>数据库名称、表名称、字段名称全部小写；</li>
<li>SQL语句必须以“;”结尾（注意需要使用英文下的 <strong>“;”</strong>）</li>
</ul>
<h1 id="8-MySQL数据类型"><a href="#8-MySQL数据类型" class="headerlink" title="8.MySQL数据类型"></a>8.MySQL数据类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p><strong>数据类型是值列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型。</strong></p>
<ul>
<li><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a><strong>数值类型</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>大小</strong></th>
<th align="left"><strong>范围（有符号）</strong></th>
<th align="left"><strong>无符号（无符号）</strong></th>
<th align="left"><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1字节</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 字节</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 字节</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">4 字节</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 字节</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4 字节</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度浮点数值</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">8 字节</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度浮点数值</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
</li>
<li><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a><strong>日期和时间类型</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>大小</strong></th>
<th align="left"><strong>范围</strong></th>
<th align="left"><strong>格式</strong></th>
<th align="left"><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left">YYYY-MM-DD HH:MM:SS</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
</li>
<li><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><strong>字符串类型</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>大小</strong></th>
<th align="left"><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 字节</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255字节</td>
<td align="left">不超过255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255字节</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535字节</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="9-MySQL常用命令"><a href="#9-MySQL常用命令" class="headerlink" title="9.MySQL常用命令"></a>9.MySQL常用命令</h1><ul>
<li><strong>注意：原意 -&gt; 缩写:</strong> database_name -&gt; db_name;table_nam -&gt; tb_name;column_name -&gt; col_name;</li>
<li><strong>显示当前服务器版本：</strong> SELECT VERSION();</li>
<li><strong>显示当前日期的时间：</strong> SELECT NOW();</li>
<li><strong>显示当前用户：</strong> SELECT USER();</li>
<li><strong>显示警告信息：</strong> SHOW WARINGS;</li>
<li><strong>显示当前服务器的数据库列表：</strong><ul>
<li>CREATE {DATABASES | SCHEMAS} [ LIKE  ‘pattern’ | WHERE expr]</li>
<li>eg: SHOW DATABASES;</li>
</ul>
</li>
<li><strong>创建数据库：</strong><ul>
<li>CREATE  {DATABASE | SCHEMA}  [IF NOT EXISTS]  db_name  [ DEFAULT ] CHARACTER SET [ = ] charset_name;</li>
<li><strong>“{}”为必选项，“|”表示N选1，“[]” 可以省略</strong></li>
<li>eg: CREATE DATABASE test;</li>
</ul>
</li>
<li><strong>显示创建数据库字符集：</strong> SHOW CREATE DATABSE db_name;</li>
<li><strong>修改数据库：</strong><ul>
<li>ALTER {DATABASE | SCHEMA}   db_name  [ DEFAULT ] CHARACTER SET [ = ] charset_name;</li>
<li>eg: ALERT DATABASE test CHARACTER SET gbk;</li>
</ul>
</li>
<li><strong>删除数据库：</strong><ul>
<li>DROP {DATABASE  | SCHEMA} [IF EXISTS] db_name ;</li>
<li>eg: DROP DATABASE test;</li>
</ul>
</li>
<li><strong>打开数据库：</strong> USE db_name;</li>
<li><strong>显示当前已经打开的数据库：</strong> SELECT DATABASE();</li>
<li><strong>创建数据表：</strong><ul>
<li>CTEATE TABLE [IF NOT EXISTS] table_name(column_name data_type,…);</li>
</ul>
</li>
<li><strong>查看数据表列表：</strong><ul>
<li>SHOW TABLES [FROM db_name] [LIKE ‘pattern’| WHERE expr]</li>
</ul>
</li>
<li><strong>查看数据表结构：</strong> SHOW COLUMNS FROM tb_name;</li>
<li><strong>查看数据表索引：</strong> SHOW INDEXES FROM tb_name;</li>
<li><strong>插入记录：</strong> INSERT [ INTO ] ta_name [(col_name,…)] VALUES (val,…);</li>
<li><strong>记录查找：</strong> SELECT expr,… FROM tb_name;</li>
<li><strong>修改数据表：</strong><ul>
<li>添加单列： ALTER TABLE tb_name ADD [ COLUMN ] col_name column_definition [ FIRST | AFTER col_name];</li>
<li>添加多列： ALTER TABLE tb_name ADD [ COLUMN ] (col_name column_definition,…);</li>
<li>删除单列： ALTER TABLE tb_name DROP col_name;</li>
<li>删除多列： ALTER TABLE tb_name DORP col_name,DROP col_name2,…;</li>
<li>添加主键约束：ALTER TABLE tb_name ADD [ CONSTRAINT [ symbol ] ] PRIMARY KEY [ index_type ] (index_col_name);</li>
<li>删除主键约束：ALTER TABLE tb_name DORP PRIMARY KEY;</li>
<li>添加唯一约束：ALTER TABLE tb_name ADD [ CONSTRAINT [ symbol ] ] UNIQUE [ INDEX | KEY ] [ index_type ] (index_col_name,…);</li>
<li>删除唯一约束：ALTER TABLE tb_name DROP { INDEX | KEY } index_name;</li>
<li>添加外键约束：ALTER TABLE tb_name ADD [ CONSTRAINT [ symbol ] ] FOREIGN KEY [ index_name ] (index_col_name,..) REFERENCES reference_definition;</li>
<li>删除外键约束：ALTER TABLE tb_name DROP FOREIGN KEY fk_symbol;</li>
<li>添加/删除默认约束：ALTER TABLE tb_name ALTER [ COLUMN ] col_name { SET DEFAULT literal | DROP DEFAULT}</li>
<li>修改列定义：ALTER TABLE tb_name MODIFY [ COLUMN ] col_name column_defintion [ FIRST | AFTER col_name];</li>
<li>修改列名称：ALTER TABLE tb_name CHANGE [ COLUMN ] old_col_name new_col_name column_defintion [ FIRST | AFTER col_name];</li>
<li>修改数据表名称：<ul>
<li>ALTER TABLE tb_name RENAME [ TO | AS ] new_tb_name;</li>
<li>RENAME TABLE tb_name TO new_tb_name [, ta_name2 TO new_tb_name2,…];</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据记录操作：</strong><ul>
<li>插入记录：<ul>
<li>INSERT [ INTO ] tb_name [ (col_name,…) ] { VALUES | VALUE } ({expr | DEFAULT},…),(…),…</li>
<li>INSERT [ INTO ] tb_name SET col_name = { expr | DEFAULT},..</li>
<li><strong>说明：</strong> 与第一种方式的区别在于，此方法可以使用子查询(SubQuery),以及不能批量插入多条数据。</li>
<li>INSERT [ INTO ] tb_name [ (col_name,…) ] SELECT …</li>
<li><strong>说明：</strong> 可以将查询的数据直接插入到指定数据表。</li>
</ul>
</li>
<li>更新记录(单表更新)：UPDATE [ LOW_PRIORITY ][ IGNORE ] table_reference SET col_name = {expr|DEFAULT}[, col_name2={expr2|DEFAULT}]…[WHRERE where_condition];</li>
<li>删除记录(单表删除)：DELETE FROM tb_name [WHERE where_condition];</li>
</ul>
</li>
</ul>
<h1 id="10-MYSQL之记录操作"><a href="#10-MYSQL之记录操作" class="headerlink" title="10.MYSQL之记录操作"></a>10.MYSQL之记录操作</h1><ul>
<li><strong>有符号与无符号：</strong> unsigned</li>
<li><strong>自动编号（自增长）：</strong> AUTO_INCREMENT</li>
<li><strong>备注：</strong> COMMENT</li>
<li><strong>空值与非空：</strong>null not null</li>
<li><strong>默认约束:</strong> DEFAULT</li>
<li><strong>主键约束：</strong> PRIMARY KEY</li>
<li><strong>唯一约束：</strong> UNIQUE KEY</li>
<li><strong>外键约束：</strong> FOREIGN KEY</li>
</ul>
<h1 id="11-约束"><a href="#11-约束" class="headerlink" title="11.约束"></a>11.约束</h1><ul>
<li>约束保证数据的完整性和一致性。</li>
<li>约束分类表级约束和列级约束。<h2 id="约束类型包括："><a href="#约束类型包括：" class="headerlink" title="约束类型包括："></a>约束类型包括：</h2></li>
<li>非空约束：NOT NULL<ul>
<li>字段禁止为空</li>
</ul>
</li>
<li>默认约束: DEFAULT<ul>
<li>当插入记录时，如果没有明确为字段赋值，则自动赋予默认值</li>
</ul>
</li>
<li>主键约束: PRIMARY KEY<ul>
<li>每张数据表智能存在一个主键</li>
<li>保证记录的唯一性</li>
<li>自动为NOT NULL</li>
</ul>
</li>
<li>唯一约束: UNIQUE KEY<ul>
<li>保证记录的唯一性</li>
<li>字段可以为空值（NULL）</li>
<li>每张数据表可以存在多个唯一约束</li>
</ul>
</li>
<li>外键约束: FOREIGN KEY<ul>
<li>保证数据一致性，完整性</li>
<li>实现一对一或一对多关系</li>
<li>外键约束要求：<ul>
<li>父表（参照表）与子表（外键表）必须使用相同的存储引擎，而且禁止使用临时表；</li>
<li>数据表的存储引擎只能为InnoDB；</li>
<li>外键列和参照列必须具有相似的数据类型。其中数字的长度或是有符号必须相同；而字符的长度则可以不同；</li>
<li>外键列和参照列必须创景索引。如果外键列不存在索引的话，MySQL将自动创建索引。</li>
</ul>
  <strong>注意：</strong>参照列没有索引，MySQL自动创建索引，而外键列没有索引，MySQL不会创景索引。</li>
<li>外键约束的参照：<ul>
<li>CASCADE:从父表删除或更新且自动删除或更新子表中匹配的行</li>
<li>SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表没有指定NOT NULL。</li>
<li>RESTRICT:拒绝对父表的删除或更新操作。</li>
<li>NO ACTION:标准SQL的关键字，在MySQL中与RESTRICT相同。</li>
</ul>
</li>
</ul>
</li>
<li>表级约束与列级约束  <ul>
<li>列级约束：对一个数据列建立的约束</li>
<li>表级约束：对多个数据列建立的约束</li>
</ul>
  <strong>注意</strong> 列级约束既可以在列定义时声明，也可以在列定以后声明；表级约束只能在列定义后声明。</li>
</ul>
]]></content>
      <categories>
        <category>基础学习篇</category>
      </categories>
  </entry>
  <entry>
    <title>从生活、工作以及交流中发现美。</title>
    <url>/2019/10/31/%E4%B8%AA%E4%BA%BA%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>那些最棒的科技公司做了什么与众不同的事情？</strong></p>
<ul>
<li>三个关键主题：<ul>
<li>提前处理风险</li>
<li>最有风险的事情就是不去承担风险</li>
<li>结果是衡量表现的唯一标准<br>个人理解: 以最低风险获得最高的收益结果</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>手记</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/31/hello-world/</url>
    <content><![CDATA[<p>铭记今天，始于2019-10-31。</p>
]]></content>
  </entry>
</search>
