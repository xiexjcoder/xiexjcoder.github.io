<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>互联网求职——中间件 | XiexjCoder Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">互联网求职——中间件</h1><a id="logo" href="/.">XiexjCoder Blog</a><p class="description">如果你不能把它简单地解释出来，那说明你还没有很好的理解它</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">互联网求职——中间件</h1><div class="post-meta">Nov 22, 2019<span> | </span><span class="category"><a href="/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C/">互联网求职</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/"></span><span> 条评论</span></a><div class="post-content"><h3 id="9-中间件-rocketmq-rabbitmq-kafka"><a href="#9-中间件-rocketmq-rabbitmq-kafka" class="headerlink" title="9. 中间件 rocketmq/rabbitmq/kafka"></a>9. <strong>中间件 rocketmq/rabbitmq/kafka</strong></h3><ul>
<li><h4 id="rabbitmq-的使用场景有哪些？"><a href="#rabbitmq-的使用场景有哪些？" class="headerlink" title="rabbitmq 的使用场景有哪些？"></a>rabbitmq 的使用场景有哪些？</h4><p>  ①. 跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。<br>  ②. 多个应用之间的耦合，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。<br>  ③. 应用内的同步变异步，比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。<br>  ④. 消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。<br>  ⑤. 应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。<br>  ⑥. 跨局域网，甚至跨城市的通讯（CDN行业），比如北京机房与广州机房的应用程序的通信。</p>
</li>
<li><h4 id="rabbitmq-有哪些重要的角色？"><a href="#rabbitmq-有哪些重要的角色？" class="headerlink" title="rabbitmq 有哪些重要的角色？"></a>rabbitmq 有哪些重要的角色？</h4><p>  RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<ul>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
</li>
<li><h4 id="rabbitmq-有哪些重要的组件？"><a href="#rabbitmq-有哪些重要的组件？" class="headerlink" title="rabbitmq 有哪些重要的组件？"></a>rabbitmq 有哪些重要的组件？</h4><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
</li>
<li><h4 id="rabbitmq-中-vhost-的作用是什么？"><a href="#rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="rabbitmq 中 vhost 的作用是什么？"></a>rabbitmq 中 vhost 的作用是什么？</h4><p>  vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ  server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 </p>
</li>
<li><h4 id="rabbitmq-的消息是怎么发送的？"><a href="#rabbitmq-的消息是怎么发送的？" class="headerlink" title="rabbitmq 的消息是怎么发送的？"></a>rabbitmq 的消息是怎么发送的？</h4><p>  首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
</li>
<li><h4 id="rabbitmq-怎么保证消息的稳定性？"><a href="#rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="rabbitmq 怎么保证消息的稳定性？"></a>rabbitmq 怎么保证消息的稳定性？</h4><ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
</li>
<li><h4 id="rabbitmq-怎么避免消息丢失？"><a href="#rabbitmq-怎么避免消息丢失？" class="headerlink" title="rabbitmq 怎么避免消息丢失？"></a>rabbitmq 怎么避免消息丢失？</h4><ul>
<li>消息持久化</li>
<li>ACK确认机制</li>
<li>设置集群镜像模式</li>
<li>消息补偿机制</li>
</ul>
</li>
<li><h4 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h4><ul>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。</li>
<li>以上四个条件都满足才能保证消息持久化成功。</li>
</ul>
</li>
<li><h4 id="rabbitmq-持久化有什么缺点？"><a href="#rabbitmq-持久化有什么缺点？" class="headerlink" title="rabbitmq 持久化有什么缺点？"></a>rabbitmq 持久化有什么缺点？</h4><p>  持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
</li>
<li><h4 id="rabbitmq-有几种广播类型？"><a href="#rabbitmq-有几种广播类型？" class="headerlink" title="rabbitmq 有几种广播类型？"></a>rabbitmq 有几种广播类型？</h4><p>  三种广播模式：</p>
<ul>
<li>fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</li>
<li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</li>
<li>topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；</li>
</ul>
</li>
<li><h4 id="rabbitmq-怎么实现延迟消息队列？"><a href="#rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="rabbitmq 怎么实现延迟消息队列？"></a>rabbitmq 怎么实现延迟消息队列？</h4><ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
</li>
<li><h4 id="rabbitmq-集群有什么用？"><a href="#rabbitmq-集群有什么用？" class="headerlink" title="rabbitmq 集群有什么用？"></a>rabbitmq 集群有什么用？</h4><p>  集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
</li>
<li><h4 id="rabbitmq-节点的类型有哪些？"><a href="#rabbitmq-节点的类型有哪些？" class="headerlink" title="rabbitmq 节点的类型有哪些？"></a>rabbitmq 节点的类型有哪些？</h4><ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
</li>
<li><h4 id="rabbitmq-集群搭建需要注意哪些问题？"><a href="#rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="rabbitmq 集群搭建需要注意哪些问题？"></a>rabbitmq 集群搭建需要注意哪些问题？</h4><ul>
<li>各节点之间使用“–link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
</li>
<li><h4 id="rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h4><p>  不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
</li>
<li><h4 id="rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h4><p>  如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</li>
</ul>
</li>
<li><h4 id="rabbitmq-对集群节点停止顺序有要求吗？"><a href="#rabbitmq-对集群节点停止顺序有要求吗？" class="headerlink" title="rabbitmq 对集群节点停止顺序有要求吗？"></a>rabbitmq 对集群节点停止顺序有要求吗？</h4><p>  RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
</li>
<li><h4 id="kafka可以脱离zookeeper单独使用吗？为什么？"><a href="#kafka可以脱离zookeeper单独使用吗？为什么？" class="headerlink" title="kafka可以脱离zookeeper单独使用吗？为什么？"></a>kafka可以脱离zookeeper单独使用吗？为什么？</h4><p>  kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
</li>
<li><h4 id="kafka有几种数据保留的策略？"><a href="#kafka有几种数据保留的策略？" class="headerlink" title="kafka有几种数据保留的策略？"></a>kafka有几种数据保留的策略？</h4><p>  kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
</li>
<li><h4 id="kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？"><a href="#kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？" class="headerlink" title="kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？"></a>kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？</h4><p>  这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
</li>
<li><h4 id="什么情况会导致kafka运行变慢？"><a href="#什么情况会导致kafka运行变慢？" class="headerlink" title="什么情况会导致kafka运行变慢？"></a>什么情况会导致kafka运行变慢？</h4><ul>
<li>cpu 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
</li>
<li><h4 id="使用kafka集群需要注意什么？"><a href="#使用kafka集群需要注意什么？" class="headerlink" title="使用kafka集群需要注意什么？"></a>使用kafka集群需要注意什么？</h4><ul>
<li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li>
<li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li>
</ul>
</li>
<li><h4 id="zookeeper是什么？"><a href="#zookeeper是什么？" class="headerlink" title="zookeeper是什么？"></a>zookeeper是什么？</h4><p>  zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
</li>
<li><h4 id="zookeeper都有哪些功能、"><a href="#zookeeper都有哪些功能、" class="headerlink" title="zookeeper都有哪些功能、"></a>zookeeper都有哪些功能、</h4><ul>
<li>集群管理：监控节点存活状态、运行请求等。</li>
<li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li>
<li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li>
<li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
</ul>
</li>
<li><h4 id="zookeeper有哪几种部署模式？"><a href="#zookeeper有哪几种部署模式？" class="headerlink" title="zookeeper有哪几种部署模式？"></a>zookeeper有哪几种部署模式？</h4><p>  zookeeper 有三种部署模式：</p>
<ul>
<li>单机部署：一台集群上运行；</li>
<li>集群部署：多台集群运行；</li>
<li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li>
</ul>
</li>
<li><h4 id="zookeeper怎么保证主从借点的状态同步？"><a href="#zookeeper怎么保证主从借点的状态同步？" class="headerlink" title="zookeeper怎么保证主从借点的状态同步？"></a>zookeeper怎么保证主从借点的状态同步？</h4><p>  zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
</li>
<li><h4 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h4><p>  在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
</li>
<li><h4 id="集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？"><a href="#集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？" class="headerlink" title="集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？"></a>集群众有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗？</h4><p>  可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
</li>
<li><h4 id="说一下zookeeper的通知机制？"><a href="#说一下zookeeper的通知机制？" class="headerlink" title="说一下zookeeper的通知机制？"></a>说一下zookeeper的通知机制？</h4><p>  客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">互联网求职——设计模式</a><a class="next" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E9%A1%B9%E7%9B%AE%E7%AF%87/">互联网求职——项目</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' ? true : false;
var verify = 'false' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'HMCVMu79BXKku7a95jqPbsfq-gzGzoHsz',
  appKey:'jvqP2PXthjron3FtNuTqIm8F',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C/">互联网求职</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87/">基础学习篇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%8B%E8%AE%B0/">手记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Junit/">单元测试工具-Junit</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/DOS%E5%91%BD%E4%BB%A4/">DOS常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%A2%97/">每天一梗</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/Redis%E5%85%A5%E9%97%A8%E7%AF%87/">Redis入门篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/%E6%AF%8F%E6%97%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E6%B8%85%E5%8D%95/">每日工作内容清单</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">IDEA使用记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">互联网求职——设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/">互联网求职——中间件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E9%A1%B9%E7%9B%AE%E7%AF%87/">互联网求职——项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BLinux%E7%AF%87/">互联网求职——LINUX</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">XiexjCoder Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>