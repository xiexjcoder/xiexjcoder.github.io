<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>互联网求职——开源框架 | XiexjCoder Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">互联网求职——开源框架</h1><a id="logo" href="/.">XiexjCoder Blog</a><p class="description">如果你不能把它简单地解释出来，那说明你还没有很好的理解它</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">互联网求职——开源框架</h1><div class="post-meta">Nov 22, 2019<span> | </span><span class="category"><a href="/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C/">互联网求职</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E7%AF%87/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E7%AF%87/"></span><span> 条评论</span></a><div class="post-content"><h3 id="开源框架spring、springmvc、springboot、springcloud、mybatis"><a href="#开源框架spring、springmvc、springboot、springcloud、mybatis" class="headerlink" title="开源框架spring、springmvc、springboot、springcloud、mybatis"></a><strong>开源框架spring、springmvc、springboot、springcloud、mybatis</strong></h3><ul>
<li><h4 id="对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"><a href="#对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。" class="headerlink" title="对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"></a>对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。</h4><p>  Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，因为通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。<br>  Spring的优点：</p>
<ol>
<li>降低了组件之间的耦合性，实现了软件各层之间的解耦。</li>
<li>可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。</li>
<li>容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。<br>Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。面向切面编程中还要理解切入点、切面、通知、织入等概念。<br>Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。</li>
</ol>
</li>
<li><h4 id="为什么要使用spring？"><a href="#为什么要使用spring？" class="headerlink" title="为什么要使用spring？"></a>为什么要使用spring？</h4><ol>
<li><strong>简介</strong><br>目的：解决企业应用开发的复杂性<br>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br>范围：任何Java应用<br>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</li>
<li><strong>轻量</strong>　　<br>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</li>
<li><strong>控制反转</strong>　　<br>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
<li><strong>面向切面</strong>　　<br>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
<li><strong>容器</strong><br>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
<li><strong>框架</strong><br>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。<br>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</li>
</ol>
</li>
<li><h4 id="解释一下什么是AOP？"><a href="#解释一下什么是AOP？" class="headerlink" title="解释一下什么是AOP？"></a>解释一下什么是AOP？</h4><p>  AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>  而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。<br>  使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。” </p>
</li>
<li><h4 id="解释一下什么是IOC？"><a href="#解释一下什么是IOC？" class="headerlink" title="解释一下什么是IOC？"></a>解释一下什么是IOC？</h4><p>  IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。<br>  1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。<br>  IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：<br>  图 IOC解耦过程<br>  大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。<br>  我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：<br>  图 拿掉IOC容器后的系统<br>  我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！<br>  我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：<br>  软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>  软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>  通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
</li>
<li><h4 id="spring有哪些主要模块？"><a href="#spring有哪些主要模块？" class="headerlink" title="spring有哪些主要模块？"></a>spring有哪些主要模块？</h4><p>  Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>
</li>
<li><h4 id="spring常用的注入方式有哪些？"><a href="#spring常用的注入方式有哪些？" class="headerlink" title="spring常用的注入方式有哪些？"></a>spring常用的注入方式有哪些？</h4><p>  Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>
<ul>
<li>构造方法注入</li>
<li>setter注入</li>
<li>基于注解的注入</li>
</ul>
</li>
<li><h4 id="spring中的bean是线程安全的吗？"><a href="#spring中的bean是线程安全的吗？" class="headerlink" title="spring中的bean是线程安全的吗？"></a>spring中的bean是线程安全的吗？</h4><p>  Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>
</li>
<li><h4 id="spring支持几种bean的作用域？"><a href="#spring支持几种bean的作用域？" class="headerlink" title="spring支持几种bean的作用域？"></a>spring支持几种bean的作用域？</h4><p>  当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>
<ul>
<li><p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</p>
</li>
<li><p>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</p>
</li>
<li><p>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
<li><p>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
<li><p>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</p>
<p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。<br>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>
</li>
</ul>
</li>
<li><h4 id="spring自动装配bean有哪些方式？"><a href="#spring自动装配bean有哪些方式？" class="headerlink" title="spring自动装配bean有哪些方式？"></a>spring自动装配bean有哪些方式？</h4><p>  Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。<br>  spring中bean装配有两种方式：</p>
<ul>
<li><p>隐式的bean发现机制和自动装配</p>
</li>
<li><p>在java代码或者XML中进行显示配置</p>
<p>当然这些方式也可以配合使用。</p>
</li>
</ul>
</li>
<li><h4 id="spring食物实现方式有哪些？"><a href="#spring食物实现方式有哪些？" class="headerlink" title="spring食物实现方式有哪些？"></a>spring食物实现方式有哪些？</h4><ul>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean 的声明式事务管理</li>
<li>基于 @Transactional 的声明式事务管理</li>
<li>基于 Aspectj AOP 配置事务</li>
</ul>
</li>
<li><h4 id="说一下spring的事物隔离？"><a href="#说一下spring的事物隔离？" class="headerlink" title="说一下spring的事物隔离？"></a>说一下spring的事物隔离？</h4><p>  事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>
<ul>
<li>脏读：一个事务读到另一个事务未提交的更新数据。</li>
<li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li>
<li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li>
</ul>
</li>
<li><h4 id="说一下springmvc运行流程？"><a href="#说一下springmvc运行流程？" class="headerlink" title="说一下springmvc运行流程？"></a>说一下springmvc运行流程？</h4><p>  Spring MVC运行流程图：<br>  Spring运行流程描述：</p>
<ol>
<li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<ol start="5">
<li>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li>
<li>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li>
<li>ViewResolver 结合Model和View，来渲染视图；</li>
<li>将渲染结果返回给客户端。</li>
</ol>
</li>
<li><h4 id="springMVC有哪些组件？"><a href="#springMVC有哪些组件？" class="headerlink" title="springMVC有哪些组件？"></a>springMVC有哪些组件？</h4><p>  Spring MVC的核心组件：</p>
<ul>
<li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li>
<li>Controller：具体处理请求的控制器</li>
<li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li>
<li>ModelAndView：服务层返回的数据和视图层的封装类</li>
<li>ViewResolver：视图解析器，解析具体的视图</li>
<li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li>
</ul>
</li>
<li><h4 id="常用注解有哪些？起什么作用？"><a href="#常用注解有哪些？起什么作用？" class="headerlink" title="常用注解有哪些？起什么作用？"></a>常用注解有哪些？起什么作用？</h4><ul>
<li>@RequestMapping<br>  RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>  RequestMapping注解有六个属性，下面我们把她分成三类进行说明。<br>  value， method：<ul>
<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li>
<li>method：指定请求的method类型， GET、POST、PUT、DELETE等；<br>consumes，produces</li>
<li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li>
<li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>params，headers</li>
<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>
<li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
</ul>
</li>
<li>@Autowired</li>
</ul>
</li>
<li><h4 id="什么是springboot？"><a href="#什么是springboot？" class="headerlink" title="什么是springboot？"></a>什么是springboot？</h4><p>  在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<bean>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。<br>  SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p>
</li>
<li><h4 id="为什么要用springboot？"><a href="#为什么要用springboot？" class="headerlink" title="为什么要用springboot？"></a>为什么要用springboot？</h4><ul>
<li>Spring Boot使编码变简单</li>
<li>Spring Boot使配置变简单</li>
<li>Spring Boot使部署变简单</li>
<li>Spring Boot使监控变简单</li>
<li>Spring的不足</li>
</ul>
</li>
<li><h4 id="springboot核心配置文件是什么？"><a href="#springboot核心配置文件是什么？" class="headerlink" title="springboot核心配置文件是什么？"></a>springboot核心配置文件是什么？</h4><p>  Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
</li>
<li><h4 id="springboot配置文件有哪几种类型？它们有什么区别？"><a href="#springboot配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="springboot配置文件有哪几种类型？它们有什么区别？"></a>springboot配置文件有哪几种类型？它们有什么区别？</h4><p>  Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</p>
</li>
<li><h4 id="springboot有哪些方式可以实现热部署？"><a href="#springboot有哪些方式可以实现热部署？" class="headerlink" title="springboot有哪些方式可以实现热部署？"></a>springboot有哪些方式可以实现热部署？</h4><p>  SpringBoot热部署实现有两种方式：<br>  ①. 使用spring loaded<br>  在项目中添加如下代码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;!-- springBoot编译插件--&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;dependencies&gt;</span><br><span class="line">                &lt;!-- spring热部署 --&gt;</span><br><span class="line">                &lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;1.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;/dependency&gt;</span><br><span class="line">            &lt;/dependencies&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>  添加完毕后需要使用mvn指令运行：<br>  首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的”+”,然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）<br>  点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可<br>  ②. 使用spring-boot-devtools<br>  在项目的pom文件中添加依赖：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热部署jar--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>  然后：使用 shift+ctrl+alt+”/“ （IDEA中的快捷键） 选择”Registry” 然后勾选 compiler.automake.allow.when.app.running</p>
</li>
<li><h4 id="什么是springcloud？"><a href="#什么是springcloud？" class="headerlink" title="什么是springcloud？"></a>什么是springcloud？</h4><p>  从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。<br>  Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。<br>  Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
<li>……<br>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</li>
</ul>
</li>
<li><h4 id="springcloud断路器的作用是什么？"><a href="#springcloud断路器的作用是什么？" class="headerlink" title="springcloud断路器的作用是什么？"></a>springcloud断路器的作用是什么？</h4><p>  在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。<br>  断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p>
</li>
<li><h4 id="springcloud的核心组件有哪些？"><a href="#springcloud的核心组件有哪些？" class="headerlink" title="springcloud的核心组件有哪些？"></a>springcloud的核心组件有哪些？</h4><p>  ①. 服务发现——Netflix Eureka<br>  一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。<br>  ②. 客服端负载均衡——Netflix Ribbon<br>  Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。<br>  ③. 断路器——Netflix Hystrix<br>  断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。<br>  ④. 服务网关——Netflix Zuul<br>  类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。<br>  ⑤. 分布式配置——Spring Cloud Config<br>  这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
</li>
<li><h4 id="什么是ORM框架？"><a href="#什么是ORM框架？" class="headerlink" title="什么是ORM框架？"></a>什么是ORM框架？</h4><p>  对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
</li>
<li><h4 id="mybatis中-和-P-的区别是什么？"><a href="#mybatis中-和-P-的区别是什么？" class="headerlink" title="mybatis中#{}和$P{}的区别是什么？"></a>mybatis中#{}和$P{}的区别是什么？</h4><ul>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>Mybatis在处理${}时，就是把${}替换成变量的值；</li>
<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ul>
</li>
<li><h4 id="mybatis有几种分页方式？"><a href="#mybatis有几种分页方式？" class="headerlink" title="mybatis有几种分页方式？"></a>mybatis有几种分页方式？</h4><ul>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ul>
</li>
<li><h4 id="mybatis逻辑分页核物理分切的区别是什么？"><a href="#mybatis逻辑分页核物理分切的区别是什么？" class="headerlink" title="mybatis逻辑分页核物理分切的区别是什么？"></a>mybatis逻辑分页核物理分切的区别是什么？</h4><ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
</li>
<li><h4 id="mybatis是否支持延迟加载？延迟加载的原理是什么？"><a href="#mybatis是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="mybatis是否支持延迟加载？延迟加载的原理是什么？"></a>mybatis是否支持延迟加载？延迟加载的原理是什么？</h4><p>  Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。<br>  它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。<br>  当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
</li>
<li><h4 id="说一下mybatis的一级缓存和二级缓存？"><a href="#说一下mybatis的一级缓存和二级缓存？" class="headerlink" title="说一下mybatis的一级缓存和二级缓存？"></a>说一下mybatis的一级缓存和二级缓存？</h4><p>  一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。<br>  二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；<br>  对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</li>
<li><h4 id="mybatis有哪些执行器？"><a href="#mybatis有哪些执行器？" class="headerlink" title="mybatis有哪些执行器？"></a>mybatis有哪些执行器？</h4><p>  Mybatis有三种基本的执行器（Executor）：</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ul>
</li>
<li><h4 id="mybatis分页插件的实现原理是什么？"><a href="#mybatis分页插件的实现原理是什么？" class="headerlink" title="mybatis分页插件的实现原理是什么？"></a>mybatis分页插件的实现原理是什么？</h4><p>  分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
</li>
<li><h4 id="mybatis如何编写一个自定义插件？"><a href="#mybatis如何编写一个自定义插件？" class="headerlink" title="mybatis如何编写一个自定义插件？"></a>mybatis如何编写一个自定义插件？</h4><p>  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为： </p>
<ul>
<li>Executor：拦截执行器的方法(log记录) </li>
<li>StatementHandler ：拦截Sql语法构建的处理 </li>
<li>ParameterHandler ：拦截参数的处理 </li>
<li>ResultSetHandler ：拦截结果集的处理<br>Mybatis自定义插件必须实现Interceptor接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">    Object intercept(Invocation invocation) throws Throwable;</span><br><span class="line">    Object plugin(Object target);</span><br><span class="line">    void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
intercept方法：拦截器具体处理逻辑方法<br>plugin方法：根据签名signatureMap生成动态代理对象<br>setProperties方法：设置Properties属性<br>自定义插件demo：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ExamplePlugin.java</span><br><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">    type= Executor.class,</span><br><span class="line">    method = &quot;update&quot;,</span><br><span class="line">    args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    Object target = invocation.getTarget(); //被代理对象</span><br><span class="line">    Method method = invocation.getMethod(); //代理方法</span><br><span class="line">    Object[] args = invocation.getArgs(); //方法参数</span><br><span class="line">    // do something ...... 方法拦截前执行代码块</span><br><span class="line">    Object result = invocation.proceed();</span><br><span class="line">    // do something .......方法拦截后执行代码块</span><br><span class="line">    return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： </li>
<li>type：表示拦截的类，这里是Executor的实现类；</li>
<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>
<li>args：表示方法参数。</li>
</ul>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BJVM%E7%AF%87/">互联网求职——JVM</a><a class="next" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BNOSQL/">互联网求职——NOSQL</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' ? true : false;
var verify = 'false' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'HMCVMu79BXKku7a95jqPbsfq-gzGzoHsz',
  appKey:'jvqP2PXthjron3FtNuTqIm8F',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C/">互联网求职</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87/">基础学习篇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%8B%E8%AE%B0/">手记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Junit/">单元测试工具-Junit</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/DOS%E5%91%BD%E4%BB%A4/">DOS常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%A2%97/">每天一梗</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/Redis%E5%85%A5%E9%97%A8%E7%AF%87/">Redis入门篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/%E6%AF%8F%E6%97%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E6%B8%85%E5%8D%95/">每日工作内容清单</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">IDEA使用记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">互联网求职——设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/">互联网求职——中间件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E9%A1%B9%E7%9B%AE%E7%AF%87/">互联网求职——项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E4%BA%92%E8%81%94%E7%BD%91%E6%B1%82%E8%81%8C%E6%8A%80%E6%9C%AF%E7%AF%87%E4%B9%8BLinux%E7%AF%87/">互联网求职——LINUX</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">XiexjCoder Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>